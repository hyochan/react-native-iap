# CLAUDE.md

## Project Overview

React Native IAP - A high-performance in-app purchase library using Nitro Modules

## Key Technologies

- React Native
- Nitro Modules (Native bridge)
- TypeScript
- Swift (iOS with StoreKit 2)
- Kotlin (Android with Google Play Billing)
- **Bun** (Package manager - MUST be used for all operations)

## Package Manager

⚠️ **IMPORTANT: This project uses Bun exclusively**

- **ALWAYS use `bun` instead of `npm` or `yarn`**
- Install dependencies: `bun install`
- Add packages: `bun add [package]`
- Run scripts: `bun run [script]`
- Execute packages: `bunx [package]`

## Project Structure

```sh
src/
├── index.tsx           # Main exports and API
├── specs/
│   └── RnIap.nitro.ts # Nitro interface definitions (native bridge)
└── types/
    └── *.ts           # TypeScript type definitions

ios/
├── HybridIAP.swift    # iOS native implementation (StoreKit 2)
└── *.swift            # Other iOS implementation files

android/
└── src/main/java/com/margelo/nitro/iap/
    └── *.kt           # Android native implementation (Play Billing)

nitrogen/
└── generated/         # Auto-generated Nitro bridge files (DO NOT EDIT)

example/               # example React Native app for testing
├── ios/
├── android/
└── package.json
```

## Development Commands

### Building and Code Generation

```bash
# Generate Nitro bridge files (nitrogen)
bun run specs

# TypeScript type checking
bun run typecheck

# Linting
bun run lint
bun run lint --fix

# Clean build artifacts
bun run clean
```

### Example App

```bash
# Navigate to example directory
cd example

# Install dependencies
bun install

# iOS
bunx react-native run-ios
bunx react-native run-ios --device  # For physical device

# Android
bunx react-native run-android

# Start Metro bundler
bunx react-native start
```

### iOS Setup

```bash
cd example/ios
bundle install  # Install Ruby dependencies
bundle exec pod install  # Install iOS dependencies
```

## VSCode Integration

The project includes VSCode launch configurations for easy development:

1. **Nitrogen + iOS Simulator**: Generates Nitro files and runs on iOS simulator
2. **Nitrogen + iOS Device**: Generates Nitro files and runs on physical iOS device
3. **Nitrogen + Android**: Generates Nitro files and runs on Android

Access these from the Run and Debug panel (⌘⇧D) in VSCode.

## Architecture Guidelines

### Module Organization

1. **src/specs/RnIap.nitro.ts** - Native Bridge Interface
   - Contains the Nitro interface definition that bridges to native code
   - Includes ALL native method declarations
   - This is the contract between TypeScript and native implementations

2. **nitrogen/** - Auto-generated Files
   - Generated by `bun run specs`
   - Contains C++ bridge code and type definitions
   - **DO NOT EDIT** - These files are auto-generated

3. **Native Implementation**
   - iOS: `ios/HybridIAP.swift` - StoreKit 2 implementation
   - Android: `android/.../Iap.kt` - Play Billing implementation with auto-reconnection
   - **Connection Management**: Uses Google Play Billing v8.0.0+ automatic service reconnection

## Coding Standards

### Commit Message Convention

- **With tag**: Use lowercase after tag (e.g., `feat: add new feature`, `fix: resolve bug`)
- **Without tag**: Start with uppercase (e.g., `Add new feature`, `Fix critical bug`)
- Common tags: `feat:`, `fix:`, `docs:`, `style:`, `refactor:`, `test:`, `chore:`

### Code Style

- ESLint configuration for TypeScript
- Prettier for code formatting
- TypeScript with strict mode
- Use type-only imports when importing types (`import type`)

## CI Checks (Run Before Committing)

**IMPORTANT**: Always run these checks locally before committing to avoid CI failures:

```bash
# Install dependencies
bun install

# TypeScript Check
bun run typecheck

# Linting
bun run lint --fix

# Generate Nitro files if specs changed
bun run specs

# Run all checks in sequence
bun install && bun run typecheck && bun run lint --fix
```

### Common CI Fixes

- TypeScript errors: Ensure all types are properly imported
- Linting errors: Use `bun run lint --fix` to auto-fix formatting issues
- Nitro generation: Run `bun run specs` after modifying `.nitro.ts` files

## Platform-Specific Features

### iOS (StoreKit 2)

- Subscription management
- Promotional offers
- Family sharing
- Refund requests
- Transaction verification
- Receipt validation

### Android (Play Billing)

- Multiple SKU purchases
- Subscription offers
- Obfuscated account/profile IDs
- Purchase acknowledgment
- Product consumption
- **Automatic Service Reconnection** - Uses `enableAutoServiceReconnection()` to handle disconnections automatically
- **Simplified Connection Handling** - Only checks if billing client exists (not connection state), auto-reconnection handles the rest

## Error Handling

### Centralized Error Management

The project uses a centralized error handling approach across all platforms:

**TypeScript (`src/utils.ts` + `src/types.ts`)**
- `parseErrorStringToJsonObj()` - Parses native error strings into structured objects
- `isUserCancelledError()` - Helper to check for user cancellation
- `ErrorCode` enum (from types.ts) - Standardized error codes across platforms

**Android (`android/src/main/java/com/margelo/nitro/iap/Types.kt`)**
- `IapErrorCode` object - Centralized error codes
- `BillingUtils.getBillingErrorData()` - Maps Android billing codes to error objects
- `BillingUtils.createErrorJson()` - Serializes errors to JSON strings

**iOS (`ios/ErrorUtils.swift`)**
- `IapErrorCode` struct - iOS error code constants (matches Android)
- `ErrorUtils.getStoreKitErrorData()` - Maps StoreKit errors to error objects
- `ErrorUtils.createErrorJson()` - Serializes errors to JSON strings

### Error Format

All native modules return errors as JSON strings:

```json
{
  "code": "E_USER_CANCELLED",
  "message": "User cancelled the purchase",
  "responseCode": 1,
  "debugMessage": "User pressed cancel",
  "productId": "dev.hyo.martie.10bulbs"
}
```

### Usage Example

```typescript
import { parseErrorStringToJsonObj, isUserCancelledError } from 'react-native-iap'

try {
  await requestPurchase({ ... })
} catch (error) {
  const parsedError = parseErrorStringToJsonObj(error)
  
  if (isUserCancelledError(parsedError)) {
    console.log('User cancelled purchase')
  } else {
    console.error('Purchase failed:', parsedError.code, parsedError.message)
  }
}
```

### Common Error Codes

- `E_USER_CANCELLED` - User cancelled the operation
- `E_ITEM_UNAVAILABLE` - Product not available in store
- `E_NETWORK_ERROR` - Network connection issues
- `E_SERVICE_ERROR` - Platform service issues
- `E_DEVELOPER_ERROR` - Invalid API usage
- `E_NOT_PREPARED` - Service not initialized
- `E_UNKNOWN` - Unexpected error

## Development Guidelines

- Always use `bun` for package management
- Run `bun run typecheck` and `bun run lint` before committing
- Regenerate Nitro files with `bun run specs` after modifying interfaces
- Use Platform.OS checks for platform-specific code
- Handle errors gracefully using `parseErrorStringToJsonObj()` utility
- Test error scenarios on both platforms

## Troubleshooting

### Common Issues

1. **Build failures after modifying .nitro.ts files**
   - Run `bun run specs` to regenerate Nitro bridge files

2. **iOS build errors**

   ```bash
   cd example/ios
   bundle exec pod install
   ```

3. **Package installation issues**
   - Ensure you're using `bun` not `npm` or `yarn`
   - Clear cache: `bun pm cache rm --all`

4. **Metro bundler issues**

   ```sh
   cd example
   bunx react-native start --reset-cache
   ```

5. **React Hook Issues (useState null error)**
   
   ⚠️ **WARNING**: Do NOT install `@testing-library/react-native` in the root package.json!
   
   Installing testing libraries in the root package.json can cause circular React import issues that break React hooks (causing "Cannot read property 'useState' of null" errors).
   
   **Solution**: Only install testing libraries in the example app's package.json, never in the root package.json.
