///
/// NitroIap-Swift-Cxx-Bridge.hpp
/// This file was generated by nitrogen. DO NOT MODIFY THIS FILE.
/// https://github.com/mrousavy/nitro
/// Copyright Â© Marc Rousavy @ Margelo
///

#pragma once

// Forward declarations of C++ defined types
// Forward declaration of `AlternativeBillingModeAndroid` to properly resolve imports.
namespace margelo::nitro::iap { enum class AlternativeBillingModeAndroid; }
// Forward declaration of `AndroidSubscriptionOfferInput` to properly resolve imports.
namespace margelo::nitro::iap { struct AndroidSubscriptionOfferInput; }
// Forward declaration of `BillingProgramAndroid` to properly resolve imports.
namespace margelo::nitro::iap { enum class BillingProgramAndroid; }
// Forward declaration of `DeveloperProvidedBillingDetailsAndroid` to properly resolve imports.
namespace margelo::nitro::iap { struct DeveloperProvidedBillingDetailsAndroid; }
// Forward declaration of `ExternalPurchaseLinkResultIOS` to properly resolve imports.
namespace margelo::nitro::iap { struct ExternalPurchaseLinkResultIOS; }
// Forward declaration of `ExternalPurchaseNoticeAction` to properly resolve imports.
namespace margelo::nitro::iap { enum class ExternalPurchaseNoticeAction; }
// Forward declaration of `ExternalPurchaseNoticeResultIOS` to properly resolve imports.
namespace margelo::nitro::iap { struct ExternalPurchaseNoticeResultIOS; }
// Forward declaration of `HybridRnIapSpec` to properly resolve imports.
namespace margelo::nitro::iap { class HybridRnIapSpec; }
// Forward declaration of `IapPlatform` to properly resolve imports.
namespace margelo::nitro::iap { enum class IapPlatform; }
// Forward declaration of `IapStore` to properly resolve imports.
namespace margelo::nitro::iap { enum class IapStore; }
// Forward declaration of `IapkitPurchaseState` to properly resolve imports.
namespace margelo::nitro::iap { enum class IapkitPurchaseState; }
// Forward declaration of `InitConnectionConfig` to properly resolve imports.
namespace margelo::nitro::iap { struct InitConnectionConfig; }
// Forward declaration of `NitroActiveSubscription` to properly resolve imports.
namespace margelo::nitro::iap { struct NitroActiveSubscription; }
// Forward declaration of `NitroAvailablePurchasesAndroidOptions` to properly resolve imports.
namespace margelo::nitro::iap { struct NitroAvailablePurchasesAndroidOptions; }
// Forward declaration of `NitroAvailablePurchasesAndroidType` to properly resolve imports.
namespace margelo::nitro::iap { enum class NitroAvailablePurchasesAndroidType; }
// Forward declaration of `NitroAvailablePurchasesIosOptions` to properly resolve imports.
namespace margelo::nitro::iap { struct NitroAvailablePurchasesIosOptions; }
// Forward declaration of `NitroAvailablePurchasesOptions` to properly resolve imports.
namespace margelo::nitro::iap { struct NitroAvailablePurchasesOptions; }
// Forward declaration of `NitroBillingProgramAvailabilityResultAndroid` to properly resolve imports.
namespace margelo::nitro::iap { struct NitroBillingProgramAvailabilityResultAndroid; }
// Forward declaration of `NitroBillingProgramReportingDetailsAndroid` to properly resolve imports.
namespace margelo::nitro::iap { struct NitroBillingProgramReportingDetailsAndroid; }
// Forward declaration of `NitroDiscountAmountAndroid` to properly resolve imports.
namespace margelo::nitro::iap { struct NitroDiscountAmountAndroid; }
// Forward declaration of `NitroDiscountDisplayInfoAndroid` to properly resolve imports.
namespace margelo::nitro::iap { struct NitroDiscountDisplayInfoAndroid; }
// Forward declaration of `NitroFinishTransactionAndroidParams` to properly resolve imports.
namespace margelo::nitro::iap { struct NitroFinishTransactionAndroidParams; }
// Forward declaration of `NitroFinishTransactionIosParams` to properly resolve imports.
namespace margelo::nitro::iap { struct NitroFinishTransactionIosParams; }
// Forward declaration of `NitroLimitedQuantityInfoAndroid` to properly resolve imports.
namespace margelo::nitro::iap { struct NitroLimitedQuantityInfoAndroid; }
// Forward declaration of `NitroOneTimePurchaseOfferDetail` to properly resolve imports.
namespace margelo::nitro::iap { struct NitroOneTimePurchaseOfferDetail; }
// Forward declaration of `NitroPreorderDetailsAndroid` to properly resolve imports.
namespace margelo::nitro::iap { struct NitroPreorderDetailsAndroid; }
// Forward declaration of `NitroProduct` to properly resolve imports.
namespace margelo::nitro::iap { struct NitroProduct; }
// Forward declaration of `NitroPurchaseResult` to properly resolve imports.
namespace margelo::nitro::iap { struct NitroPurchaseResult; }
// Forward declaration of `NitroPurchase` to properly resolve imports.
namespace margelo::nitro::iap { struct NitroPurchase; }
// Forward declaration of `NitroReceiptValidationAppleOptions` to properly resolve imports.
namespace margelo::nitro::iap { struct NitroReceiptValidationAppleOptions; }
// Forward declaration of `NitroReceiptValidationGoogleOptions` to properly resolve imports.
namespace margelo::nitro::iap { struct NitroReceiptValidationGoogleOptions; }
// Forward declaration of `NitroReceiptValidationHorizonOptions` to properly resolve imports.
namespace margelo::nitro::iap { struct NitroReceiptValidationHorizonOptions; }
// Forward declaration of `NitroReceiptValidationResultAndroid` to properly resolve imports.
namespace margelo::nitro::iap { struct NitroReceiptValidationResultAndroid; }
// Forward declaration of `NitroReceiptValidationResultIOS` to properly resolve imports.
namespace margelo::nitro::iap { struct NitroReceiptValidationResultIOS; }
// Forward declaration of `NitroRenewalInfoIOS` to properly resolve imports.
namespace margelo::nitro::iap { struct NitroRenewalInfoIOS; }
// Forward declaration of `NitroRentalDetailsAndroid` to properly resolve imports.
namespace margelo::nitro::iap { struct NitroRentalDetailsAndroid; }
// Forward declaration of `NitroRequestPurchaseAndroid` to properly resolve imports.
namespace margelo::nitro::iap { struct NitroRequestPurchaseAndroid; }
// Forward declaration of `NitroRequestPurchaseIos` to properly resolve imports.
namespace margelo::nitro::iap { struct NitroRequestPurchaseIos; }
// Forward declaration of `NitroSubscriptionRenewalInfo` to properly resolve imports.
namespace margelo::nitro::iap { struct NitroSubscriptionRenewalInfo; }
// Forward declaration of `NitroSubscriptionStatus` to properly resolve imports.
namespace margelo::nitro::iap { struct NitroSubscriptionStatus; }
// Forward declaration of `NitroValidTimeWindowAndroid` to properly resolve imports.
namespace margelo::nitro::iap { struct NitroValidTimeWindowAndroid; }
// Forward declaration of `NitroVerifyPurchaseWithIapkitAppleProps` to properly resolve imports.
namespace margelo::nitro::iap { struct NitroVerifyPurchaseWithIapkitAppleProps; }
// Forward declaration of `NitroVerifyPurchaseWithIapkitGoogleProps` to properly resolve imports.
namespace margelo::nitro::iap { struct NitroVerifyPurchaseWithIapkitGoogleProps; }
// Forward declaration of `NitroVerifyPurchaseWithIapkitProps` to properly resolve imports.
namespace margelo::nitro::iap { struct NitroVerifyPurchaseWithIapkitProps; }
// Forward declaration of `NitroVerifyPurchaseWithIapkitResult` to properly resolve imports.
namespace margelo::nitro::iap { struct NitroVerifyPurchaseWithIapkitResult; }
// Forward declaration of `NitroVerifyPurchaseWithProviderError` to properly resolve imports.
namespace margelo::nitro::iap { struct NitroVerifyPurchaseWithProviderError; }
// Forward declaration of `NitroVerifyPurchaseWithProviderResult` to properly resolve imports.
namespace margelo::nitro::iap { struct NitroVerifyPurchaseWithProviderResult; }
// Forward declaration of `PaymentModeIOS` to properly resolve imports.
namespace margelo::nitro::iap { enum class PaymentModeIOS; }
// Forward declaration of `PurchaseAndroid` to properly resolve imports.
namespace margelo::nitro::iap { struct PurchaseAndroid; }
// Forward declaration of `PurchaseIOS` to properly resolve imports.
namespace margelo::nitro::iap { struct PurchaseIOS; }
// Forward declaration of `PurchaseOfferIOS` to properly resolve imports.
namespace margelo::nitro::iap { struct PurchaseOfferIOS; }
// Forward declaration of `PurchaseState` to properly resolve imports.
namespace margelo::nitro::iap { enum class PurchaseState; }
// Forward declaration of `PurchaseVerificationProvider` to properly resolve imports.
namespace margelo::nitro::iap { enum class PurchaseVerificationProvider; }
// Forward declaration of `RenewalInfoIOS` to properly resolve imports.
namespace margelo::nitro::iap { struct RenewalInfoIOS; }
// Forward declaration of `UserChoiceBillingDetails` to properly resolve imports.
namespace margelo::nitro::iap { struct UserChoiceBillingDetails; }

// Forward declarations of Swift defined types
// Forward declaration of `HybridRnIapSpec_cxx` to properly resolve imports.
namespace NitroIap { class HybridRnIapSpec_cxx; }

// Include C++ defined types
#include "AlternativeBillingModeAndroid.hpp"
#include "AndroidSubscriptionOfferInput.hpp"
#include "BillingProgramAndroid.hpp"
#include "DeveloperProvidedBillingDetailsAndroid.hpp"
#include "ExternalPurchaseLinkResultIOS.hpp"
#include "ExternalPurchaseNoticeAction.hpp"
#include "ExternalPurchaseNoticeResultIOS.hpp"
#include "HybridRnIapSpec.hpp"
#include "IapPlatform.hpp"
#include "IapStore.hpp"
#include "IapkitPurchaseState.hpp"
#include "InitConnectionConfig.hpp"
#include "NitroActiveSubscription.hpp"
#include "NitroAvailablePurchasesAndroidOptions.hpp"
#include "NitroAvailablePurchasesAndroidType.hpp"
#include "NitroAvailablePurchasesIosOptions.hpp"
#include "NitroAvailablePurchasesOptions.hpp"
#include "NitroBillingProgramAvailabilityResultAndroid.hpp"
#include "NitroBillingProgramReportingDetailsAndroid.hpp"
#include "NitroDiscountAmountAndroid.hpp"
#include "NitroDiscountDisplayInfoAndroid.hpp"
#include "NitroFinishTransactionAndroidParams.hpp"
#include "NitroFinishTransactionIosParams.hpp"
#include "NitroLimitedQuantityInfoAndroid.hpp"
#include "NitroOneTimePurchaseOfferDetail.hpp"
#include "NitroPreorderDetailsAndroid.hpp"
#include "NitroProduct.hpp"
#include "NitroPurchase.hpp"
#include "NitroPurchaseResult.hpp"
#include "NitroReceiptValidationAppleOptions.hpp"
#include "NitroReceiptValidationGoogleOptions.hpp"
#include "NitroReceiptValidationHorizonOptions.hpp"
#include "NitroReceiptValidationResultAndroid.hpp"
#include "NitroReceiptValidationResultIOS.hpp"
#include "NitroRenewalInfoIOS.hpp"
#include "NitroRentalDetailsAndroid.hpp"
#include "NitroRequestPurchaseAndroid.hpp"
#include "NitroRequestPurchaseIos.hpp"
#include "NitroSubscriptionRenewalInfo.hpp"
#include "NitroSubscriptionStatus.hpp"
#include "NitroValidTimeWindowAndroid.hpp"
#include "NitroVerifyPurchaseWithIapkitAppleProps.hpp"
#include "NitroVerifyPurchaseWithIapkitGoogleProps.hpp"
#include "NitroVerifyPurchaseWithIapkitProps.hpp"
#include "NitroVerifyPurchaseWithIapkitResult.hpp"
#include "NitroVerifyPurchaseWithProviderError.hpp"
#include "NitroVerifyPurchaseWithProviderResult.hpp"
#include "PaymentModeIOS.hpp"
#include "PurchaseAndroid.hpp"
#include "PurchaseIOS.hpp"
#include "PurchaseOfferIOS.hpp"
#include "PurchaseState.hpp"
#include "PurchaseVerificationProvider.hpp"
#include "RenewalInfoIOS.hpp"
#include "UserChoiceBillingDetails.hpp"
#include <NitroModules/Null.hpp>
#include <NitroModules/Promise.hpp>
#include <NitroModules/PromiseHolder.hpp>
#include <NitroModules/Result.hpp>
#include <exception>
#include <functional>
#include <memory>
#include <optional>
#include <string>
#include <unordered_map>
#include <variant>
#include <vector>

/**
 * Contains specialized versions of C++ templated types so they can be accessed from Swift,
 * as well as helper functions to interact with those C++ types from Swift.
 */
namespace margelo::nitro::iap::bridge::swift {

  // pragma MARK: std::shared_ptr<Promise<bool>>
  /**
   * Specialized version of `std::shared_ptr<Promise<bool>>`.
   */
  using std__shared_ptr_Promise_bool__ = std::shared_ptr<Promise<bool>>;
  inline std::shared_ptr<Promise<bool>> create_std__shared_ptr_Promise_bool__() noexcept {
    return Promise<bool>::create();
  }
  inline PromiseHolder<bool> wrap_std__shared_ptr_Promise_bool__(std::shared_ptr<Promise<bool>> promise) noexcept {
    return PromiseHolder<bool>(std::move(promise));
  }
  
  // pragma MARK: std::function<void(bool /* result */)>
  /**
   * Specialized version of `std::function<void(bool)>`.
   */
  using Func_void_bool = std::function<void(bool /* result */)>;
  /**
   * Wrapper class for a `std::function<void(bool / * result * /)>`, this can be used from Swift.
   */
  class Func_void_bool_Wrapper final {
  public:
    explicit Func_void_bool_Wrapper(std::function<void(bool /* result */)>&& func): _function(std::make_unique<std::function<void(bool /* result */)>>(std::move(func))) {}
    inline void call(bool result) const noexcept {
      _function->operator()(result);
    }
  private:
    std::unique_ptr<std::function<void(bool /* result */)>> _function;
  } SWIFT_NONCOPYABLE;
  Func_void_bool create_Func_void_bool(void* NON_NULL swiftClosureWrapper) noexcept;
  inline Func_void_bool_Wrapper wrap_Func_void_bool(Func_void_bool value) noexcept {
    return Func_void_bool_Wrapper(std::move(value));
  }
  
  // pragma MARK: std::function<void(const std::exception_ptr& /* error */)>
  /**
   * Specialized version of `std::function<void(const std::exception_ptr&)>`.
   */
  using Func_void_std__exception_ptr = std::function<void(const std::exception_ptr& /* error */)>;
  /**
   * Wrapper class for a `std::function<void(const std::exception_ptr& / * error * /)>`, this can be used from Swift.
   */
  class Func_void_std__exception_ptr_Wrapper final {
  public:
    explicit Func_void_std__exception_ptr_Wrapper(std::function<void(const std::exception_ptr& /* error */)>&& func): _function(std::make_unique<std::function<void(const std::exception_ptr& /* error */)>>(std::move(func))) {}
    inline void call(std::exception_ptr error) const noexcept {
      _function->operator()(error);
    }
  private:
    std::unique_ptr<std::function<void(const std::exception_ptr& /* error */)>> _function;
  } SWIFT_NONCOPYABLE;
  Func_void_std__exception_ptr create_Func_void_std__exception_ptr(void* NON_NULL swiftClosureWrapper) noexcept;
  inline Func_void_std__exception_ptr_Wrapper wrap_Func_void_std__exception_ptr(Func_void_std__exception_ptr value) noexcept {
    return Func_void_std__exception_ptr_Wrapper(std::move(value));
  }
  
  // pragma MARK: std::optional<AlternativeBillingModeAndroid>
  /**
   * Specialized version of `std::optional<AlternativeBillingModeAndroid>`.
   */
  using std__optional_AlternativeBillingModeAndroid_ = std::optional<AlternativeBillingModeAndroid>;
  inline std::optional<AlternativeBillingModeAndroid> create_std__optional_AlternativeBillingModeAndroid_(const AlternativeBillingModeAndroid& value) noexcept {
    return std::optional<AlternativeBillingModeAndroid>(value);
  }
  inline bool has_value_std__optional_AlternativeBillingModeAndroid_(const std::optional<AlternativeBillingModeAndroid>& optional) noexcept {
    return optional.has_value();
  }
  inline AlternativeBillingModeAndroid get_std__optional_AlternativeBillingModeAndroid_(const std::optional<AlternativeBillingModeAndroid>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::optional<BillingProgramAndroid>
  /**
   * Specialized version of `std::optional<BillingProgramAndroid>`.
   */
  using std__optional_BillingProgramAndroid_ = std::optional<BillingProgramAndroid>;
  inline std::optional<BillingProgramAndroid> create_std__optional_BillingProgramAndroid_(const BillingProgramAndroid& value) noexcept {
    return std::optional<BillingProgramAndroid>(value);
  }
  inline bool has_value_std__optional_BillingProgramAndroid_(const std::optional<BillingProgramAndroid>& optional) noexcept {
    return optional.has_value();
  }
  inline BillingProgramAndroid get_std__optional_BillingProgramAndroid_(const std::optional<BillingProgramAndroid>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::variant<nitro::NullType, InitConnectionConfig>
  /**
   * Wrapper struct for `std::variant<nitro::NullType, InitConnectionConfig>`.
   * std::variant cannot be used in Swift because of a Swift bug.
   * Not even specializing it works. So we create a wrapper struct.
   */
  struct std__variant_nitro__NullType__InitConnectionConfig_ final {
    std::variant<nitro::NullType, InitConnectionConfig> variant;
    std__variant_nitro__NullType__InitConnectionConfig_(std::variant<nitro::NullType, InitConnectionConfig> variant): variant(variant) { }
    operator std::variant<nitro::NullType, InitConnectionConfig>() const noexcept {
      return variant;
    }
    inline size_t index() const noexcept {
      return variant.index();
    }
    inline nitro::NullType get_0() const noexcept {
      return std::get<0>(variant);
    }
    inline InitConnectionConfig get_1() const noexcept {
      return std::get<1>(variant);
    }
  };
  inline std__variant_nitro__NullType__InitConnectionConfig_ create_std__variant_nitro__NullType__InitConnectionConfig_(nitro::NullType value) noexcept {
    return std__variant_nitro__NullType__InitConnectionConfig_(value);
  }
  inline std__variant_nitro__NullType__InitConnectionConfig_ create_std__variant_nitro__NullType__InitConnectionConfig_(const InitConnectionConfig& value) noexcept {
    return std__variant_nitro__NullType__InitConnectionConfig_(value);
  }
  
  // pragma MARK: std::optional<std::variant<nitro::NullType, InitConnectionConfig>>
  /**
   * Specialized version of `std::optional<std::variant<nitro::NullType, InitConnectionConfig>>`.
   */
  using std__optional_std__variant_nitro__NullType__InitConnectionConfig__ = std::optional<std::variant<nitro::NullType, InitConnectionConfig>>;
  inline std::optional<std::variant<nitro::NullType, InitConnectionConfig>> create_std__optional_std__variant_nitro__NullType__InitConnectionConfig__(const std::variant<nitro::NullType, InitConnectionConfig>& value) noexcept {
    return std::optional<std::variant<nitro::NullType, InitConnectionConfig>>(value);
  }
  inline bool has_value_std__optional_std__variant_nitro__NullType__InitConnectionConfig__(const std::optional<std::variant<nitro::NullType, InitConnectionConfig>>& optional) noexcept {
    return optional.has_value();
  }
  inline std::variant<nitro::NullType, InitConnectionConfig> get_std__optional_std__variant_nitro__NullType__InitConnectionConfig__(const std::optional<std::variant<nitro::NullType, InitConnectionConfig>>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::variant<nitro::NullType, std::string>
  /**
   * Wrapper struct for `std::variant<nitro::NullType, std::string>`.
   * std::variant cannot be used in Swift because of a Swift bug.
   * Not even specializing it works. So we create a wrapper struct.
   */
  struct std__variant_nitro__NullType__std__string_ final {
    std::variant<nitro::NullType, std::string> variant;
    std__variant_nitro__NullType__std__string_(std::variant<nitro::NullType, std::string> variant): variant(variant) { }
    operator std::variant<nitro::NullType, std::string>() const noexcept {
      return variant;
    }
    inline size_t index() const noexcept {
      return variant.index();
    }
    inline nitro::NullType get_0() const noexcept {
      return std::get<0>(variant);
    }
    inline std::string get_1() const noexcept {
      return std::get<1>(variant);
    }
  };
  inline std__variant_nitro__NullType__std__string_ create_std__variant_nitro__NullType__std__string_(nitro::NullType value) noexcept {
    return std__variant_nitro__NullType__std__string_(value);
  }
  inline std__variant_nitro__NullType__std__string_ create_std__variant_nitro__NullType__std__string_(const std::string& value) noexcept {
    return std__variant_nitro__NullType__std__string_(value);
  }
  
  // pragma MARK: std::optional<std::variant<nitro::NullType, std::string>>
  /**
   * Specialized version of `std::optional<std::variant<nitro::NullType, std::string>>`.
   */
  using std__optional_std__variant_nitro__NullType__std__string__ = std::optional<std::variant<nitro::NullType, std::string>>;
  inline std::optional<std::variant<nitro::NullType, std::string>> create_std__optional_std__variant_nitro__NullType__std__string__(const std::variant<nitro::NullType, std::string>& value) noexcept {
    return std::optional<std::variant<nitro::NullType, std::string>>(value);
  }
  inline bool has_value_std__optional_std__variant_nitro__NullType__std__string__(const std::optional<std::variant<nitro::NullType, std::string>>& optional) noexcept {
    return optional.has_value();
  }
  inline std::variant<nitro::NullType, std::string> get_std__optional_std__variant_nitro__NullType__std__string__(const std::optional<std::variant<nitro::NullType, std::string>>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::optional<std::string>
  /**
   * Specialized version of `std::optional<std::string>`.
   */
  using std__optional_std__string_ = std::optional<std::string>;
  inline std::optional<std::string> create_std__optional_std__string_(const std::string& value) noexcept {
    return std::optional<std::string>(value);
  }
  inline bool has_value_std__optional_std__string_(const std::optional<std::string>& optional) noexcept {
    return optional.has_value();
  }
  inline std::string get_std__optional_std__string_(const std::optional<std::string>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::variant<nitro::NullType, double>
  /**
   * Wrapper struct for `std::variant<nitro::NullType, double>`.
   * std::variant cannot be used in Swift because of a Swift bug.
   * Not even specializing it works. So we create a wrapper struct.
   */
  struct std__variant_nitro__NullType__double_ final {
    std::variant<nitro::NullType, double> variant;
    std__variant_nitro__NullType__double_(std::variant<nitro::NullType, double> variant): variant(variant) { }
    operator std::variant<nitro::NullType, double>() const noexcept {
      return variant;
    }
    inline size_t index() const noexcept {
      return variant.index();
    }
    inline nitro::NullType get_0() const noexcept {
      return std::get<0>(variant);
    }
    inline double get_1() const noexcept {
      return std::get<1>(variant);
    }
  };
  inline std__variant_nitro__NullType__double_ create_std__variant_nitro__NullType__double_(nitro::NullType value) noexcept {
    return std__variant_nitro__NullType__double_(value);
  }
  inline std__variant_nitro__NullType__double_ create_std__variant_nitro__NullType__double_(double value) noexcept {
    return std__variant_nitro__NullType__double_(value);
  }
  
  // pragma MARK: std::optional<std::variant<nitro::NullType, double>>
  /**
   * Specialized version of `std::optional<std::variant<nitro::NullType, double>>`.
   */
  using std__optional_std__variant_nitro__NullType__double__ = std::optional<std::variant<nitro::NullType, double>>;
  inline std::optional<std::variant<nitro::NullType, double>> create_std__optional_std__variant_nitro__NullType__double__(const std::variant<nitro::NullType, double>& value) noexcept {
    return std::optional<std::variant<nitro::NullType, double>>(value);
  }
  inline bool has_value_std__optional_std__variant_nitro__NullType__double__(const std::optional<std::variant<nitro::NullType, double>>& optional) noexcept {
    return optional.has_value();
  }
  inline std::variant<nitro::NullType, double> get_std__optional_std__variant_nitro__NullType__double__(const std::optional<std::variant<nitro::NullType, double>>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::variant<nitro::NullType, bool>
  /**
   * Wrapper struct for `std::variant<nitro::NullType, bool>`.
   * std::variant cannot be used in Swift because of a Swift bug.
   * Not even specializing it works. So we create a wrapper struct.
   */
  struct std__variant_nitro__NullType__bool_ final {
    std::variant<nitro::NullType, bool> variant;
    std__variant_nitro__NullType__bool_(std::variant<nitro::NullType, bool> variant): variant(variant) { }
    operator std::variant<nitro::NullType, bool>() const noexcept {
      return variant;
    }
    inline size_t index() const noexcept {
      return variant.index();
    }
    inline nitro::NullType get_0() const noexcept {
      return std::get<0>(variant);
    }
    inline bool get_1() const noexcept {
      return std::get<1>(variant);
    }
  };
  inline std__variant_nitro__NullType__bool_ create_std__variant_nitro__NullType__bool_(nitro::NullType value) noexcept {
    return std__variant_nitro__NullType__bool_(value);
  }
  inline std__variant_nitro__NullType__bool_ create_std__variant_nitro__NullType__bool_(bool value) noexcept {
    return std__variant_nitro__NullType__bool_(value);
  }
  
  // pragma MARK: std::optional<std::variant<nitro::NullType, bool>>
  /**
   * Specialized version of `std::optional<std::variant<nitro::NullType, bool>>`.
   */
  using std__optional_std__variant_nitro__NullType__bool__ = std::optional<std::variant<nitro::NullType, bool>>;
  inline std::optional<std::variant<nitro::NullType, bool>> create_std__optional_std__variant_nitro__NullType__bool__(const std::variant<nitro::NullType, bool>& value) noexcept {
    return std::optional<std::variant<nitro::NullType, bool>>(value);
  }
  inline bool has_value_std__optional_std__variant_nitro__NullType__bool__(const std::optional<std::variant<nitro::NullType, bool>>& optional) noexcept {
    return optional.has_value();
  }
  inline std::variant<nitro::NullType, bool> get_std__optional_std__variant_nitro__NullType__bool__(const std::optional<std::variant<nitro::NullType, bool>>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::variant<nitro::NullType, NitroDiscountAmountAndroid>
  /**
   * Wrapper struct for `std::variant<nitro::NullType, NitroDiscountAmountAndroid>`.
   * std::variant cannot be used in Swift because of a Swift bug.
   * Not even specializing it works. So we create a wrapper struct.
   */
  struct std__variant_nitro__NullType__NitroDiscountAmountAndroid_ final {
    std::variant<nitro::NullType, NitroDiscountAmountAndroid> variant;
    std__variant_nitro__NullType__NitroDiscountAmountAndroid_(std::variant<nitro::NullType, NitroDiscountAmountAndroid> variant): variant(variant) { }
    operator std::variant<nitro::NullType, NitroDiscountAmountAndroid>() const noexcept {
      return variant;
    }
    inline size_t index() const noexcept {
      return variant.index();
    }
    inline nitro::NullType get_0() const noexcept {
      return std::get<0>(variant);
    }
    inline NitroDiscountAmountAndroid get_1() const noexcept {
      return std::get<1>(variant);
    }
  };
  inline std__variant_nitro__NullType__NitroDiscountAmountAndroid_ create_std__variant_nitro__NullType__NitroDiscountAmountAndroid_(nitro::NullType value) noexcept {
    return std__variant_nitro__NullType__NitroDiscountAmountAndroid_(value);
  }
  inline std__variant_nitro__NullType__NitroDiscountAmountAndroid_ create_std__variant_nitro__NullType__NitroDiscountAmountAndroid_(const NitroDiscountAmountAndroid& value) noexcept {
    return std__variant_nitro__NullType__NitroDiscountAmountAndroid_(value);
  }
  
  // pragma MARK: std::optional<std::variant<nitro::NullType, NitroDiscountAmountAndroid>>
  /**
   * Specialized version of `std::optional<std::variant<nitro::NullType, NitroDiscountAmountAndroid>>`.
   */
  using std__optional_std__variant_nitro__NullType__NitroDiscountAmountAndroid__ = std::optional<std::variant<nitro::NullType, NitroDiscountAmountAndroid>>;
  inline std::optional<std::variant<nitro::NullType, NitroDiscountAmountAndroid>> create_std__optional_std__variant_nitro__NullType__NitroDiscountAmountAndroid__(const std::variant<nitro::NullType, NitroDiscountAmountAndroid>& value) noexcept {
    return std::optional<std::variant<nitro::NullType, NitroDiscountAmountAndroid>>(value);
  }
  inline bool has_value_std__optional_std__variant_nitro__NullType__NitroDiscountAmountAndroid__(const std::optional<std::variant<nitro::NullType, NitroDiscountAmountAndroid>>& optional) noexcept {
    return optional.has_value();
  }
  inline std::variant<nitro::NullType, NitroDiscountAmountAndroid> get_std__optional_std__variant_nitro__NullType__NitroDiscountAmountAndroid__(const std::optional<std::variant<nitro::NullType, NitroDiscountAmountAndroid>>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::variant<nitro::NullType, NitroDiscountDisplayInfoAndroid>
  /**
   * Wrapper struct for `std::variant<nitro::NullType, NitroDiscountDisplayInfoAndroid>`.
   * std::variant cannot be used in Swift because of a Swift bug.
   * Not even specializing it works. So we create a wrapper struct.
   */
  struct std__variant_nitro__NullType__NitroDiscountDisplayInfoAndroid_ final {
    std::variant<nitro::NullType, NitroDiscountDisplayInfoAndroid> variant;
    std__variant_nitro__NullType__NitroDiscountDisplayInfoAndroid_(std::variant<nitro::NullType, NitroDiscountDisplayInfoAndroid> variant): variant(variant) { }
    operator std::variant<nitro::NullType, NitroDiscountDisplayInfoAndroid>() const noexcept {
      return variant;
    }
    inline size_t index() const noexcept {
      return variant.index();
    }
    inline nitro::NullType get_0() const noexcept {
      return std::get<0>(variant);
    }
    inline NitroDiscountDisplayInfoAndroid get_1() const noexcept {
      return std::get<1>(variant);
    }
  };
  inline std__variant_nitro__NullType__NitroDiscountDisplayInfoAndroid_ create_std__variant_nitro__NullType__NitroDiscountDisplayInfoAndroid_(nitro::NullType value) noexcept {
    return std__variant_nitro__NullType__NitroDiscountDisplayInfoAndroid_(value);
  }
  inline std__variant_nitro__NullType__NitroDiscountDisplayInfoAndroid_ create_std__variant_nitro__NullType__NitroDiscountDisplayInfoAndroid_(const NitroDiscountDisplayInfoAndroid& value) noexcept {
    return std__variant_nitro__NullType__NitroDiscountDisplayInfoAndroid_(value);
  }
  
  // pragma MARK: std::optional<std::variant<nitro::NullType, NitroDiscountDisplayInfoAndroid>>
  /**
   * Specialized version of `std::optional<std::variant<nitro::NullType, NitroDiscountDisplayInfoAndroid>>`.
   */
  using std__optional_std__variant_nitro__NullType__NitroDiscountDisplayInfoAndroid__ = std::optional<std::variant<nitro::NullType, NitroDiscountDisplayInfoAndroid>>;
  inline std::optional<std::variant<nitro::NullType, NitroDiscountDisplayInfoAndroid>> create_std__optional_std__variant_nitro__NullType__NitroDiscountDisplayInfoAndroid__(const std::variant<nitro::NullType, NitroDiscountDisplayInfoAndroid>& value) noexcept {
    return std::optional<std::variant<nitro::NullType, NitroDiscountDisplayInfoAndroid>>(value);
  }
  inline bool has_value_std__optional_std__variant_nitro__NullType__NitroDiscountDisplayInfoAndroid__(const std::optional<std::variant<nitro::NullType, NitroDiscountDisplayInfoAndroid>>& optional) noexcept {
    return optional.has_value();
  }
  inline std::variant<nitro::NullType, NitroDiscountDisplayInfoAndroid> get_std__optional_std__variant_nitro__NullType__NitroDiscountDisplayInfoAndroid__(const std::optional<std::variant<nitro::NullType, NitroDiscountDisplayInfoAndroid>>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::variant<nitro::NullType, NitroLimitedQuantityInfoAndroid>
  /**
   * Wrapper struct for `std::variant<nitro::NullType, NitroLimitedQuantityInfoAndroid>`.
   * std::variant cannot be used in Swift because of a Swift bug.
   * Not even specializing it works. So we create a wrapper struct.
   */
  struct std__variant_nitro__NullType__NitroLimitedQuantityInfoAndroid_ final {
    std::variant<nitro::NullType, NitroLimitedQuantityInfoAndroid> variant;
    std__variant_nitro__NullType__NitroLimitedQuantityInfoAndroid_(std::variant<nitro::NullType, NitroLimitedQuantityInfoAndroid> variant): variant(variant) { }
    operator std::variant<nitro::NullType, NitroLimitedQuantityInfoAndroid>() const noexcept {
      return variant;
    }
    inline size_t index() const noexcept {
      return variant.index();
    }
    inline nitro::NullType get_0() const noexcept {
      return std::get<0>(variant);
    }
    inline NitroLimitedQuantityInfoAndroid get_1() const noexcept {
      return std::get<1>(variant);
    }
  };
  inline std__variant_nitro__NullType__NitroLimitedQuantityInfoAndroid_ create_std__variant_nitro__NullType__NitroLimitedQuantityInfoAndroid_(nitro::NullType value) noexcept {
    return std__variant_nitro__NullType__NitroLimitedQuantityInfoAndroid_(value);
  }
  inline std__variant_nitro__NullType__NitroLimitedQuantityInfoAndroid_ create_std__variant_nitro__NullType__NitroLimitedQuantityInfoAndroid_(const NitroLimitedQuantityInfoAndroid& value) noexcept {
    return std__variant_nitro__NullType__NitroLimitedQuantityInfoAndroid_(value);
  }
  
  // pragma MARK: std::optional<std::variant<nitro::NullType, NitroLimitedQuantityInfoAndroid>>
  /**
   * Specialized version of `std::optional<std::variant<nitro::NullType, NitroLimitedQuantityInfoAndroid>>`.
   */
  using std__optional_std__variant_nitro__NullType__NitroLimitedQuantityInfoAndroid__ = std::optional<std::variant<nitro::NullType, NitroLimitedQuantityInfoAndroid>>;
  inline std::optional<std::variant<nitro::NullType, NitroLimitedQuantityInfoAndroid>> create_std__optional_std__variant_nitro__NullType__NitroLimitedQuantityInfoAndroid__(const std::variant<nitro::NullType, NitroLimitedQuantityInfoAndroid>& value) noexcept {
    return std::optional<std::variant<nitro::NullType, NitroLimitedQuantityInfoAndroid>>(value);
  }
  inline bool has_value_std__optional_std__variant_nitro__NullType__NitroLimitedQuantityInfoAndroid__(const std::optional<std::variant<nitro::NullType, NitroLimitedQuantityInfoAndroid>>& optional) noexcept {
    return optional.has_value();
  }
  inline std::variant<nitro::NullType, NitroLimitedQuantityInfoAndroid> get_std__optional_std__variant_nitro__NullType__NitroLimitedQuantityInfoAndroid__(const std::optional<std::variant<nitro::NullType, NitroLimitedQuantityInfoAndroid>>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::vector<std::string>
  /**
   * Specialized version of `std::vector<std::string>`.
   */
  using std__vector_std__string_ = std::vector<std::string>;
  inline std::vector<std::string> create_std__vector_std__string_(size_t size) noexcept {
    std::vector<std::string> vector;
    vector.reserve(size);
    return vector;
  }
  
  // pragma MARK: std::variant<nitro::NullType, NitroPreorderDetailsAndroid>
  /**
   * Wrapper struct for `std::variant<nitro::NullType, NitroPreorderDetailsAndroid>`.
   * std::variant cannot be used in Swift because of a Swift bug.
   * Not even specializing it works. So we create a wrapper struct.
   */
  struct std__variant_nitro__NullType__NitroPreorderDetailsAndroid_ final {
    std::variant<nitro::NullType, NitroPreorderDetailsAndroid> variant;
    std__variant_nitro__NullType__NitroPreorderDetailsAndroid_(std::variant<nitro::NullType, NitroPreorderDetailsAndroid> variant): variant(variant) { }
    operator std::variant<nitro::NullType, NitroPreorderDetailsAndroid>() const noexcept {
      return variant;
    }
    inline size_t index() const noexcept {
      return variant.index();
    }
    inline nitro::NullType get_0() const noexcept {
      return std::get<0>(variant);
    }
    inline NitroPreorderDetailsAndroid get_1() const noexcept {
      return std::get<1>(variant);
    }
  };
  inline std__variant_nitro__NullType__NitroPreorderDetailsAndroid_ create_std__variant_nitro__NullType__NitroPreorderDetailsAndroid_(nitro::NullType value) noexcept {
    return std__variant_nitro__NullType__NitroPreorderDetailsAndroid_(value);
  }
  inline std__variant_nitro__NullType__NitroPreorderDetailsAndroid_ create_std__variant_nitro__NullType__NitroPreorderDetailsAndroid_(const NitroPreorderDetailsAndroid& value) noexcept {
    return std__variant_nitro__NullType__NitroPreorderDetailsAndroid_(value);
  }
  
  // pragma MARK: std::optional<std::variant<nitro::NullType, NitroPreorderDetailsAndroid>>
  /**
   * Specialized version of `std::optional<std::variant<nitro::NullType, NitroPreorderDetailsAndroid>>`.
   */
  using std__optional_std__variant_nitro__NullType__NitroPreorderDetailsAndroid__ = std::optional<std::variant<nitro::NullType, NitroPreorderDetailsAndroid>>;
  inline std::optional<std::variant<nitro::NullType, NitroPreorderDetailsAndroid>> create_std__optional_std__variant_nitro__NullType__NitroPreorderDetailsAndroid__(const std::variant<nitro::NullType, NitroPreorderDetailsAndroid>& value) noexcept {
    return std::optional<std::variant<nitro::NullType, NitroPreorderDetailsAndroid>>(value);
  }
  inline bool has_value_std__optional_std__variant_nitro__NullType__NitroPreorderDetailsAndroid__(const std::optional<std::variant<nitro::NullType, NitroPreorderDetailsAndroid>>& optional) noexcept {
    return optional.has_value();
  }
  inline std::variant<nitro::NullType, NitroPreorderDetailsAndroid> get_std__optional_std__variant_nitro__NullType__NitroPreorderDetailsAndroid__(const std::optional<std::variant<nitro::NullType, NitroPreorderDetailsAndroid>>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::variant<nitro::NullType, NitroRentalDetailsAndroid>
  /**
   * Wrapper struct for `std::variant<nitro::NullType, NitroRentalDetailsAndroid>`.
   * std::variant cannot be used in Swift because of a Swift bug.
   * Not even specializing it works. So we create a wrapper struct.
   */
  struct std__variant_nitro__NullType__NitroRentalDetailsAndroid_ final {
    std::variant<nitro::NullType, NitroRentalDetailsAndroid> variant;
    std__variant_nitro__NullType__NitroRentalDetailsAndroid_(std::variant<nitro::NullType, NitroRentalDetailsAndroid> variant): variant(variant) { }
    operator std::variant<nitro::NullType, NitroRentalDetailsAndroid>() const noexcept {
      return variant;
    }
    inline size_t index() const noexcept {
      return variant.index();
    }
    inline nitro::NullType get_0() const noexcept {
      return std::get<0>(variant);
    }
    inline NitroRentalDetailsAndroid get_1() const noexcept {
      return std::get<1>(variant);
    }
  };
  inline std__variant_nitro__NullType__NitroRentalDetailsAndroid_ create_std__variant_nitro__NullType__NitroRentalDetailsAndroid_(nitro::NullType value) noexcept {
    return std__variant_nitro__NullType__NitroRentalDetailsAndroid_(value);
  }
  inline std__variant_nitro__NullType__NitroRentalDetailsAndroid_ create_std__variant_nitro__NullType__NitroRentalDetailsAndroid_(const NitroRentalDetailsAndroid& value) noexcept {
    return std__variant_nitro__NullType__NitroRentalDetailsAndroid_(value);
  }
  
  // pragma MARK: std::optional<std::variant<nitro::NullType, NitroRentalDetailsAndroid>>
  /**
   * Specialized version of `std::optional<std::variant<nitro::NullType, NitroRentalDetailsAndroid>>`.
   */
  using std__optional_std__variant_nitro__NullType__NitroRentalDetailsAndroid__ = std::optional<std::variant<nitro::NullType, NitroRentalDetailsAndroid>>;
  inline std::optional<std::variant<nitro::NullType, NitroRentalDetailsAndroid>> create_std__optional_std__variant_nitro__NullType__NitroRentalDetailsAndroid__(const std::variant<nitro::NullType, NitroRentalDetailsAndroid>& value) noexcept {
    return std::optional<std::variant<nitro::NullType, NitroRentalDetailsAndroid>>(value);
  }
  inline bool has_value_std__optional_std__variant_nitro__NullType__NitroRentalDetailsAndroid__(const std::optional<std::variant<nitro::NullType, NitroRentalDetailsAndroid>>& optional) noexcept {
    return optional.has_value();
  }
  inline std::variant<nitro::NullType, NitroRentalDetailsAndroid> get_std__optional_std__variant_nitro__NullType__NitroRentalDetailsAndroid__(const std::optional<std::variant<nitro::NullType, NitroRentalDetailsAndroid>>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::variant<nitro::NullType, NitroValidTimeWindowAndroid>
  /**
   * Wrapper struct for `std::variant<nitro::NullType, NitroValidTimeWindowAndroid>`.
   * std::variant cannot be used in Swift because of a Swift bug.
   * Not even specializing it works. So we create a wrapper struct.
   */
  struct std__variant_nitro__NullType__NitroValidTimeWindowAndroid_ final {
    std::variant<nitro::NullType, NitroValidTimeWindowAndroid> variant;
    std__variant_nitro__NullType__NitroValidTimeWindowAndroid_(std::variant<nitro::NullType, NitroValidTimeWindowAndroid> variant): variant(variant) { }
    operator std::variant<nitro::NullType, NitroValidTimeWindowAndroid>() const noexcept {
      return variant;
    }
    inline size_t index() const noexcept {
      return variant.index();
    }
    inline nitro::NullType get_0() const noexcept {
      return std::get<0>(variant);
    }
    inline NitroValidTimeWindowAndroid get_1() const noexcept {
      return std::get<1>(variant);
    }
  };
  inline std__variant_nitro__NullType__NitroValidTimeWindowAndroid_ create_std__variant_nitro__NullType__NitroValidTimeWindowAndroid_(nitro::NullType value) noexcept {
    return std__variant_nitro__NullType__NitroValidTimeWindowAndroid_(value);
  }
  inline std__variant_nitro__NullType__NitroValidTimeWindowAndroid_ create_std__variant_nitro__NullType__NitroValidTimeWindowAndroid_(const NitroValidTimeWindowAndroid& value) noexcept {
    return std__variant_nitro__NullType__NitroValidTimeWindowAndroid_(value);
  }
  
  // pragma MARK: std::optional<std::variant<nitro::NullType, NitroValidTimeWindowAndroid>>
  /**
   * Specialized version of `std::optional<std::variant<nitro::NullType, NitroValidTimeWindowAndroid>>`.
   */
  using std__optional_std__variant_nitro__NullType__NitroValidTimeWindowAndroid__ = std::optional<std::variant<nitro::NullType, NitroValidTimeWindowAndroid>>;
  inline std::optional<std::variant<nitro::NullType, NitroValidTimeWindowAndroid>> create_std__optional_std__variant_nitro__NullType__NitroValidTimeWindowAndroid__(const std::variant<nitro::NullType, NitroValidTimeWindowAndroid>& value) noexcept {
    return std::optional<std::variant<nitro::NullType, NitroValidTimeWindowAndroid>>(value);
  }
  inline bool has_value_std__optional_std__variant_nitro__NullType__NitroValidTimeWindowAndroid__(const std::optional<std::variant<nitro::NullType, NitroValidTimeWindowAndroid>>& optional) noexcept {
    return optional.has_value();
  }
  inline std::variant<nitro::NullType, NitroValidTimeWindowAndroid> get_std__optional_std__variant_nitro__NullType__NitroValidTimeWindowAndroid__(const std::optional<std::variant<nitro::NullType, NitroValidTimeWindowAndroid>>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::vector<NitroOneTimePurchaseOfferDetail>
  /**
   * Specialized version of `std::vector<NitroOneTimePurchaseOfferDetail>`.
   */
  using std__vector_NitroOneTimePurchaseOfferDetail_ = std::vector<NitroOneTimePurchaseOfferDetail>;
  inline std::vector<NitroOneTimePurchaseOfferDetail> create_std__vector_NitroOneTimePurchaseOfferDetail_(size_t size) noexcept {
    std::vector<NitroOneTimePurchaseOfferDetail> vector;
    vector.reserve(size);
    return vector;
  }
  
  // pragma MARK: std::variant<nitro::NullType, std::vector<NitroOneTimePurchaseOfferDetail>>
  /**
   * Wrapper struct for `std::variant<nitro::NullType, std::vector<NitroOneTimePurchaseOfferDetail>>`.
   * std::variant cannot be used in Swift because of a Swift bug.
   * Not even specializing it works. So we create a wrapper struct.
   */
  struct std__variant_nitro__NullType__std__vector_NitroOneTimePurchaseOfferDetail__ final {
    std::variant<nitro::NullType, std::vector<NitroOneTimePurchaseOfferDetail>> variant;
    std__variant_nitro__NullType__std__vector_NitroOneTimePurchaseOfferDetail__(std::variant<nitro::NullType, std::vector<NitroOneTimePurchaseOfferDetail>> variant): variant(variant) { }
    operator std::variant<nitro::NullType, std::vector<NitroOneTimePurchaseOfferDetail>>() const noexcept {
      return variant;
    }
    inline size_t index() const noexcept {
      return variant.index();
    }
    inline nitro::NullType get_0() const noexcept {
      return std::get<0>(variant);
    }
    inline std::vector<NitroOneTimePurchaseOfferDetail> get_1() const noexcept {
      return std::get<1>(variant);
    }
  };
  inline std__variant_nitro__NullType__std__vector_NitroOneTimePurchaseOfferDetail__ create_std__variant_nitro__NullType__std__vector_NitroOneTimePurchaseOfferDetail__(nitro::NullType value) noexcept {
    return std__variant_nitro__NullType__std__vector_NitroOneTimePurchaseOfferDetail__(value);
  }
  inline std__variant_nitro__NullType__std__vector_NitroOneTimePurchaseOfferDetail__ create_std__variant_nitro__NullType__std__vector_NitroOneTimePurchaseOfferDetail__(const std::vector<NitroOneTimePurchaseOfferDetail>& value) noexcept {
    return std__variant_nitro__NullType__std__vector_NitroOneTimePurchaseOfferDetail__(value);
  }
  
  // pragma MARK: std::optional<std::variant<nitro::NullType, std::vector<NitroOneTimePurchaseOfferDetail>>>
  /**
   * Specialized version of `std::optional<std::variant<nitro::NullType, std::vector<NitroOneTimePurchaseOfferDetail>>>`.
   */
  using std__optional_std__variant_nitro__NullType__std__vector_NitroOneTimePurchaseOfferDetail___ = std::optional<std::variant<nitro::NullType, std::vector<NitroOneTimePurchaseOfferDetail>>>;
  inline std::optional<std::variant<nitro::NullType, std::vector<NitroOneTimePurchaseOfferDetail>>> create_std__optional_std__variant_nitro__NullType__std__vector_NitroOneTimePurchaseOfferDetail___(const std::variant<nitro::NullType, std::vector<NitroOneTimePurchaseOfferDetail>>& value) noexcept {
    return std::optional<std::variant<nitro::NullType, std::vector<NitroOneTimePurchaseOfferDetail>>>(value);
  }
  inline bool has_value_std__optional_std__variant_nitro__NullType__std__vector_NitroOneTimePurchaseOfferDetail___(const std::optional<std::variant<nitro::NullType, std::vector<NitroOneTimePurchaseOfferDetail>>>& optional) noexcept {
    return optional.has_value();
  }
  inline std::variant<nitro::NullType, std::vector<NitroOneTimePurchaseOfferDetail>> get_std__optional_std__variant_nitro__NullType__std__vector_NitroOneTimePurchaseOfferDetail___(const std::optional<std::variant<nitro::NullType, std::vector<NitroOneTimePurchaseOfferDetail>>>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::vector<NitroProduct>
  /**
   * Specialized version of `std::vector<NitroProduct>`.
   */
  using std__vector_NitroProduct_ = std::vector<NitroProduct>;
  inline std::vector<NitroProduct> create_std__vector_NitroProduct_(size_t size) noexcept {
    std::vector<NitroProduct> vector;
    vector.reserve(size);
    return vector;
  }
  
  // pragma MARK: std::shared_ptr<Promise<std::vector<NitroProduct>>>
  /**
   * Specialized version of `std::shared_ptr<Promise<std::vector<NitroProduct>>>`.
   */
  using std__shared_ptr_Promise_std__vector_NitroProduct___ = std::shared_ptr<Promise<std::vector<NitroProduct>>>;
  inline std::shared_ptr<Promise<std::vector<NitroProduct>>> create_std__shared_ptr_Promise_std__vector_NitroProduct___() noexcept {
    return Promise<std::vector<NitroProduct>>::create();
  }
  inline PromiseHolder<std::vector<NitroProduct>> wrap_std__shared_ptr_Promise_std__vector_NitroProduct___(std::shared_ptr<Promise<std::vector<NitroProduct>>> promise) noexcept {
    return PromiseHolder<std::vector<NitroProduct>>(std::move(promise));
  }
  
  // pragma MARK: std::function<void(const std::vector<NitroProduct>& /* result */)>
  /**
   * Specialized version of `std::function<void(const std::vector<NitroProduct>&)>`.
   */
  using Func_void_std__vector_NitroProduct_ = std::function<void(const std::vector<NitroProduct>& /* result */)>;
  /**
   * Wrapper class for a `std::function<void(const std::vector<NitroProduct>& / * result * /)>`, this can be used from Swift.
   */
  class Func_void_std__vector_NitroProduct__Wrapper final {
  public:
    explicit Func_void_std__vector_NitroProduct__Wrapper(std::function<void(const std::vector<NitroProduct>& /* result */)>&& func): _function(std::make_unique<std::function<void(const std::vector<NitroProduct>& /* result */)>>(std::move(func))) {}
    inline void call(std::vector<NitroProduct> result) const noexcept {
      _function->operator()(result);
    }
  private:
    std::unique_ptr<std::function<void(const std::vector<NitroProduct>& /* result */)>> _function;
  } SWIFT_NONCOPYABLE;
  Func_void_std__vector_NitroProduct_ create_Func_void_std__vector_NitroProduct_(void* NON_NULL swiftClosureWrapper) noexcept;
  inline Func_void_std__vector_NitroProduct__Wrapper wrap_Func_void_std__vector_NitroProduct_(Func_void_std__vector_NitroProduct_ value) noexcept {
    return Func_void_std__vector_NitroProduct__Wrapper(std::move(value));
  }
  
  // pragma MARK: std::variant<nitro::NullType, std::vector<std::string>>
  /**
   * Wrapper struct for `std::variant<nitro::NullType, std::vector<std::string>>`.
   * std::variant cannot be used in Swift because of a Swift bug.
   * Not even specializing it works. So we create a wrapper struct.
   */
  struct std__variant_nitro__NullType__std__vector_std__string__ final {
    std::variant<nitro::NullType, std::vector<std::string>> variant;
    std__variant_nitro__NullType__std__vector_std__string__(std::variant<nitro::NullType, std::vector<std::string>> variant): variant(variant) { }
    operator std::variant<nitro::NullType, std::vector<std::string>>() const noexcept {
      return variant;
    }
    inline size_t index() const noexcept {
      return variant.index();
    }
    inline nitro::NullType get_0() const noexcept {
      return std::get<0>(variant);
    }
    inline std::vector<std::string> get_1() const noexcept {
      return std::get<1>(variant);
    }
  };
  inline std__variant_nitro__NullType__std__vector_std__string__ create_std__variant_nitro__NullType__std__vector_std__string__(nitro::NullType value) noexcept {
    return std__variant_nitro__NullType__std__vector_std__string__(value);
  }
  inline std__variant_nitro__NullType__std__vector_std__string__ create_std__variant_nitro__NullType__std__vector_std__string__(const std::vector<std::string>& value) noexcept {
    return std__variant_nitro__NullType__std__vector_std__string__(value);
  }
  
  // pragma MARK: std::optional<std::variant<nitro::NullType, std::vector<std::string>>>
  /**
   * Specialized version of `std::optional<std::variant<nitro::NullType, std::vector<std::string>>>`.
   */
  using std__optional_std__variant_nitro__NullType__std__vector_std__string___ = std::optional<std::variant<nitro::NullType, std::vector<std::string>>>;
  inline std::optional<std::variant<nitro::NullType, std::vector<std::string>>> create_std__optional_std__variant_nitro__NullType__std__vector_std__string___(const std::variant<nitro::NullType, std::vector<std::string>>& value) noexcept {
    return std::optional<std::variant<nitro::NullType, std::vector<std::string>>>(value);
  }
  inline bool has_value_std__optional_std__variant_nitro__NullType__std__vector_std__string___(const std::optional<std::variant<nitro::NullType, std::vector<std::string>>>& optional) noexcept {
    return optional.has_value();
  }
  inline std::variant<nitro::NullType, std::vector<std::string>> get_std__optional_std__variant_nitro__NullType__std__vector_std__string___(const std::optional<std::variant<nitro::NullType, std::vector<std::string>>>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::variant<nitro::NullType, PurchaseOfferIOS>
  /**
   * Wrapper struct for `std::variant<nitro::NullType, PurchaseOfferIOS>`.
   * std::variant cannot be used in Swift because of a Swift bug.
   * Not even specializing it works. So we create a wrapper struct.
   */
  struct std__variant_nitro__NullType__PurchaseOfferIOS_ final {
    std::variant<nitro::NullType, PurchaseOfferIOS> variant;
    std__variant_nitro__NullType__PurchaseOfferIOS_(std::variant<nitro::NullType, PurchaseOfferIOS> variant): variant(variant) { }
    operator std::variant<nitro::NullType, PurchaseOfferIOS>() const noexcept {
      return variant;
    }
    inline size_t index() const noexcept {
      return variant.index();
    }
    inline nitro::NullType get_0() const noexcept {
      return std::get<0>(variant);
    }
    inline PurchaseOfferIOS get_1() const noexcept {
      return std::get<1>(variant);
    }
  };
  inline std__variant_nitro__NullType__PurchaseOfferIOS_ create_std__variant_nitro__NullType__PurchaseOfferIOS_(nitro::NullType value) noexcept {
    return std__variant_nitro__NullType__PurchaseOfferIOS_(value);
  }
  inline std__variant_nitro__NullType__PurchaseOfferIOS_ create_std__variant_nitro__NullType__PurchaseOfferIOS_(const PurchaseOfferIOS& value) noexcept {
    return std__variant_nitro__NullType__PurchaseOfferIOS_(value);
  }
  
  // pragma MARK: std::optional<std::variant<nitro::NullType, PurchaseOfferIOS>>
  /**
   * Specialized version of `std::optional<std::variant<nitro::NullType, PurchaseOfferIOS>>`.
   */
  using std__optional_std__variant_nitro__NullType__PurchaseOfferIOS__ = std::optional<std::variant<nitro::NullType, PurchaseOfferIOS>>;
  inline std::optional<std::variant<nitro::NullType, PurchaseOfferIOS>> create_std__optional_std__variant_nitro__NullType__PurchaseOfferIOS__(const std::variant<nitro::NullType, PurchaseOfferIOS>& value) noexcept {
    return std::optional<std::variant<nitro::NullType, PurchaseOfferIOS>>(value);
  }
  inline bool has_value_std__optional_std__variant_nitro__NullType__PurchaseOfferIOS__(const std::optional<std::variant<nitro::NullType, PurchaseOfferIOS>>& optional) noexcept {
    return optional.has_value();
  }
  inline std::variant<nitro::NullType, PurchaseOfferIOS> get_std__optional_std__variant_nitro__NullType__PurchaseOfferIOS__(const std::optional<std::variant<nitro::NullType, PurchaseOfferIOS>>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::variant<nitro::NullType, RenewalInfoIOS>
  /**
   * Wrapper struct for `std::variant<nitro::NullType, RenewalInfoIOS>`.
   * std::variant cannot be used in Swift because of a Swift bug.
   * Not even specializing it works. So we create a wrapper struct.
   */
  struct std__variant_nitro__NullType__RenewalInfoIOS_ final {
    std::variant<nitro::NullType, RenewalInfoIOS> variant;
    std__variant_nitro__NullType__RenewalInfoIOS_(std::variant<nitro::NullType, RenewalInfoIOS> variant): variant(variant) { }
    operator std::variant<nitro::NullType, RenewalInfoIOS>() const noexcept {
      return variant;
    }
    inline size_t index() const noexcept {
      return variant.index();
    }
    inline nitro::NullType get_0() const noexcept {
      return std::get<0>(variant);
    }
    inline RenewalInfoIOS get_1() const noexcept {
      return std::get<1>(variant);
    }
  };
  inline std__variant_nitro__NullType__RenewalInfoIOS_ create_std__variant_nitro__NullType__RenewalInfoIOS_(nitro::NullType value) noexcept {
    return std__variant_nitro__NullType__RenewalInfoIOS_(value);
  }
  inline std__variant_nitro__NullType__RenewalInfoIOS_ create_std__variant_nitro__NullType__RenewalInfoIOS_(const RenewalInfoIOS& value) noexcept {
    return std__variant_nitro__NullType__RenewalInfoIOS_(value);
  }
  
  // pragma MARK: std::optional<std::variant<nitro::NullType, RenewalInfoIOS>>
  /**
   * Specialized version of `std::optional<std::variant<nitro::NullType, RenewalInfoIOS>>`.
   */
  using std__optional_std__variant_nitro__NullType__RenewalInfoIOS__ = std::optional<std::variant<nitro::NullType, RenewalInfoIOS>>;
  inline std::optional<std::variant<nitro::NullType, RenewalInfoIOS>> create_std__optional_std__variant_nitro__NullType__RenewalInfoIOS__(const std::variant<nitro::NullType, RenewalInfoIOS>& value) noexcept {
    return std::optional<std::variant<nitro::NullType, RenewalInfoIOS>>(value);
  }
  inline bool has_value_std__optional_std__variant_nitro__NullType__RenewalInfoIOS__(const std::optional<std::variant<nitro::NullType, RenewalInfoIOS>>& optional) noexcept {
    return optional.has_value();
  }
  inline std::variant<nitro::NullType, RenewalInfoIOS> get_std__optional_std__variant_nitro__NullType__RenewalInfoIOS__(const std::optional<std::variant<nitro::NullType, RenewalInfoIOS>>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::variant<PurchaseAndroid, PurchaseIOS>
  /**
   * Wrapper struct for `std::variant<PurchaseAndroid, PurchaseIOS>`.
   * std::variant cannot be used in Swift because of a Swift bug.
   * Not even specializing it works. So we create a wrapper struct.
   */
  struct std__variant_PurchaseAndroid__PurchaseIOS_ final {
    std::variant<PurchaseAndroid, PurchaseIOS> variant;
    std__variant_PurchaseAndroid__PurchaseIOS_(std::variant<PurchaseAndroid, PurchaseIOS> variant): variant(variant) { }
    operator std::variant<PurchaseAndroid, PurchaseIOS>() const noexcept {
      return variant;
    }
    inline size_t index() const noexcept {
      return variant.index();
    }
    inline PurchaseAndroid get_0() const noexcept {
      return std::get<0>(variant);
    }
    inline PurchaseIOS get_1() const noexcept {
      return std::get<1>(variant);
    }
  };
  inline std__variant_PurchaseAndroid__PurchaseIOS_ create_std__variant_PurchaseAndroid__PurchaseIOS_(const PurchaseAndroid& value) noexcept {
    return std__variant_PurchaseAndroid__PurchaseIOS_(value);
  }
  inline std__variant_PurchaseAndroid__PurchaseIOS_ create_std__variant_PurchaseAndroid__PurchaseIOS_(const PurchaseIOS& value) noexcept {
    return std__variant_PurchaseAndroid__PurchaseIOS_(value);
  }
  
  // pragma MARK: std::vector<std::variant<PurchaseAndroid, PurchaseIOS>>
  /**
   * Specialized version of `std::vector<std::variant<PurchaseAndroid, PurchaseIOS>>`.
   */
  using std__vector_std__variant_PurchaseAndroid__PurchaseIOS__ = std::vector<std::variant<PurchaseAndroid, PurchaseIOS>>;
  inline std::vector<std::variant<PurchaseAndroid, PurchaseIOS>> create_std__vector_std__variant_PurchaseAndroid__PurchaseIOS__(size_t size) noexcept {
    std::vector<std::variant<PurchaseAndroid, PurchaseIOS>> vector;
    vector.reserve(size);
    return vector;
  }
  
  // pragma MARK: std::variant<nitro::NullType, PurchaseAndroid, PurchaseIOS, std::vector<std::variant<PurchaseAndroid, PurchaseIOS>>>
  /**
   * Wrapper struct for `std::variant<nitro::NullType, PurchaseAndroid, PurchaseIOS, std::vector<std::variant<PurchaseAndroid, PurchaseIOS>>>`.
   * std::variant cannot be used in Swift because of a Swift bug.
   * Not even specializing it works. So we create a wrapper struct.
   */
  struct std__variant_nitro__NullType__PurchaseAndroid__PurchaseIOS__std__vector_std__variant_PurchaseAndroid__PurchaseIOS___ final {
    std::variant<nitro::NullType, PurchaseAndroid, PurchaseIOS, std::vector<std::variant<PurchaseAndroid, PurchaseIOS>>> variant;
    std__variant_nitro__NullType__PurchaseAndroid__PurchaseIOS__std__vector_std__variant_PurchaseAndroid__PurchaseIOS___(std::variant<nitro::NullType, PurchaseAndroid, PurchaseIOS, std::vector<std::variant<PurchaseAndroid, PurchaseIOS>>> variant): variant(variant) { }
    operator std::variant<nitro::NullType, PurchaseAndroid, PurchaseIOS, std::vector<std::variant<PurchaseAndroid, PurchaseIOS>>>() const noexcept {
      return variant;
    }
    inline size_t index() const noexcept {
      return variant.index();
    }
    inline nitro::NullType get_0() const noexcept {
      return std::get<0>(variant);
    }
    inline PurchaseAndroid get_1() const noexcept {
      return std::get<1>(variant);
    }
    inline PurchaseIOS get_2() const noexcept {
      return std::get<2>(variant);
    }
    inline std::vector<std::variant<PurchaseAndroid, PurchaseIOS>> get_3() const noexcept {
      return std::get<3>(variant);
    }
  };
  inline std__variant_nitro__NullType__PurchaseAndroid__PurchaseIOS__std__vector_std__variant_PurchaseAndroid__PurchaseIOS___ create_std__variant_nitro__NullType__PurchaseAndroid__PurchaseIOS__std__vector_std__variant_PurchaseAndroid__PurchaseIOS___(nitro::NullType value) noexcept {
    return std__variant_nitro__NullType__PurchaseAndroid__PurchaseIOS__std__vector_std__variant_PurchaseAndroid__PurchaseIOS___(value);
  }
  inline std__variant_nitro__NullType__PurchaseAndroid__PurchaseIOS__std__vector_std__variant_PurchaseAndroid__PurchaseIOS___ create_std__variant_nitro__NullType__PurchaseAndroid__PurchaseIOS__std__vector_std__variant_PurchaseAndroid__PurchaseIOS___(const PurchaseAndroid& value) noexcept {
    return std__variant_nitro__NullType__PurchaseAndroid__PurchaseIOS__std__vector_std__variant_PurchaseAndroid__PurchaseIOS___(value);
  }
  inline std__variant_nitro__NullType__PurchaseAndroid__PurchaseIOS__std__vector_std__variant_PurchaseAndroid__PurchaseIOS___ create_std__variant_nitro__NullType__PurchaseAndroid__PurchaseIOS__std__vector_std__variant_PurchaseAndroid__PurchaseIOS___(const PurchaseIOS& value) noexcept {
    return std__variant_nitro__NullType__PurchaseAndroid__PurchaseIOS__std__vector_std__variant_PurchaseAndroid__PurchaseIOS___(value);
  }
  inline std__variant_nitro__NullType__PurchaseAndroid__PurchaseIOS__std__vector_std__variant_PurchaseAndroid__PurchaseIOS___ create_std__variant_nitro__NullType__PurchaseAndroid__PurchaseIOS__std__vector_std__variant_PurchaseAndroid__PurchaseIOS___(const std::vector<std::variant<PurchaseAndroid, PurchaseIOS>>& value) noexcept {
    return std__variant_nitro__NullType__PurchaseAndroid__PurchaseIOS__std__vector_std__variant_PurchaseAndroid__PurchaseIOS___(value);
  }
  
  // pragma MARK: std::shared_ptr<Promise<std::variant<nitro::NullType, PurchaseAndroid, PurchaseIOS, std::vector<std::variant<PurchaseAndroid, PurchaseIOS>>>>>
  /**
   * Specialized version of `std::shared_ptr<Promise<std::variant<nitro::NullType, PurchaseAndroid, PurchaseIOS, std::vector<std::variant<PurchaseAndroid, PurchaseIOS>>>>>`.
   */
  using std__shared_ptr_Promise_std__variant_nitro__NullType__PurchaseAndroid__PurchaseIOS__std__vector_std__variant_PurchaseAndroid__PurchaseIOS_____ = std::shared_ptr<Promise<std::variant<nitro::NullType, PurchaseAndroid, PurchaseIOS, std::vector<std::variant<PurchaseAndroid, PurchaseIOS>>>>>;
  inline std::shared_ptr<Promise<std::variant<nitro::NullType, PurchaseAndroid, PurchaseIOS, std::vector<std::variant<PurchaseAndroid, PurchaseIOS>>>>> create_std__shared_ptr_Promise_std__variant_nitro__NullType__PurchaseAndroid__PurchaseIOS__std__vector_std__variant_PurchaseAndroid__PurchaseIOS_____() noexcept {
    return Promise<std::variant<nitro::NullType, PurchaseAndroid, PurchaseIOS, std::vector<std::variant<PurchaseAndroid, PurchaseIOS>>>>::create();
  }
  inline PromiseHolder<std::variant<nitro::NullType, PurchaseAndroid, PurchaseIOS, std::vector<std::variant<PurchaseAndroid, PurchaseIOS>>>> wrap_std__shared_ptr_Promise_std__variant_nitro__NullType__PurchaseAndroid__PurchaseIOS__std__vector_std__variant_PurchaseAndroid__PurchaseIOS_____(std::shared_ptr<Promise<std::variant<nitro::NullType, PurchaseAndroid, PurchaseIOS, std::vector<std::variant<PurchaseAndroid, PurchaseIOS>>>>> promise) noexcept {
    return PromiseHolder<std::variant<nitro::NullType, PurchaseAndroid, PurchaseIOS, std::vector<std::variant<PurchaseAndroid, PurchaseIOS>>>>(std::move(promise));
  }
  
  // pragma MARK: std::function<void(const std::variant<nitro::NullType, PurchaseAndroid, PurchaseIOS, std::vector<std::variant<PurchaseAndroid, PurchaseIOS>>>& /* result */)>
  /**
   * Specialized version of `std::function<void(const std::variant<nitro::NullType, PurchaseAndroid, PurchaseIOS, std::vector<std::variant<PurchaseAndroid, PurchaseIOS>>>&)>`.
   */
  using Func_void_std__variant_nitro__NullType__PurchaseAndroid__PurchaseIOS__std__vector_std__variant_PurchaseAndroid__PurchaseIOS___ = std::function<void(const std::variant<nitro::NullType, PurchaseAndroid, PurchaseIOS, std::vector<std::variant<PurchaseAndroid, PurchaseIOS>>>& /* result */)>;
  /**
   * Wrapper class for a `std::function<void(const std::variant<nitro::NullType, PurchaseAndroid, PurchaseIOS, std::vector<std::variant<PurchaseAndroid, PurchaseIOS>>>& / * result * /)>`, this can be used from Swift.
   */
  class Func_void_std__variant_nitro__NullType__PurchaseAndroid__PurchaseIOS__std__vector_std__variant_PurchaseAndroid__PurchaseIOS____Wrapper final {
  public:
    explicit Func_void_std__variant_nitro__NullType__PurchaseAndroid__PurchaseIOS__std__vector_std__variant_PurchaseAndroid__PurchaseIOS____Wrapper(std::function<void(const std::variant<nitro::NullType, PurchaseAndroid, PurchaseIOS, std::vector<std::variant<PurchaseAndroid, PurchaseIOS>>>& /* result */)>&& func): _function(std::make_unique<std::function<void(const std::variant<nitro::NullType, PurchaseAndroid, PurchaseIOS, std::vector<std::variant<PurchaseAndroid, PurchaseIOS>>>& /* result */)>>(std::move(func))) {}
    inline void call(std::variant<nitro::NullType, PurchaseAndroid, PurchaseIOS, std::vector<std::variant<PurchaseAndroid, PurchaseIOS>>> result) const noexcept {
      _function->operator()(result);
    }
  private:
    std::unique_ptr<std::function<void(const std::variant<nitro::NullType, PurchaseAndroid, PurchaseIOS, std::vector<std::variant<PurchaseAndroid, PurchaseIOS>>>& /* result */)>> _function;
  } SWIFT_NONCOPYABLE;
  Func_void_std__variant_nitro__NullType__PurchaseAndroid__PurchaseIOS__std__vector_std__variant_PurchaseAndroid__PurchaseIOS___ create_Func_void_std__variant_nitro__NullType__PurchaseAndroid__PurchaseIOS__std__vector_std__variant_PurchaseAndroid__PurchaseIOS___(void* NON_NULL swiftClosureWrapper) noexcept;
  inline Func_void_std__variant_nitro__NullType__PurchaseAndroid__PurchaseIOS__std__vector_std__variant_PurchaseAndroid__PurchaseIOS____Wrapper wrap_Func_void_std__variant_nitro__NullType__PurchaseAndroid__PurchaseIOS__std__vector_std__variant_PurchaseAndroid__PurchaseIOS___(Func_void_std__variant_nitro__NullType__PurchaseAndroid__PurchaseIOS__std__vector_std__variant_PurchaseAndroid__PurchaseIOS___ value) noexcept {
    return Func_void_std__variant_nitro__NullType__PurchaseAndroid__PurchaseIOS__std__vector_std__variant_PurchaseAndroid__PurchaseIOS____Wrapper(std::move(value));
  }
  
  // pragma MARK: std::unordered_map<std::string, std::string>
  /**
   * Specialized version of `std::unordered_map<std::string, std::string>`.
   */
  using std__unordered_map_std__string__std__string_ = std::unordered_map<std::string, std::string>;
  inline std::unordered_map<std::string, std::string> create_std__unordered_map_std__string__std__string_(size_t size) noexcept {
    std::unordered_map<std::string, std::string> map;
    map.reserve(size);
    return map;
  }
  inline std::vector<std::string> get_std__unordered_map_std__string__std__string__keys(const std__unordered_map_std__string__std__string_& map) noexcept {
    std::vector<std::string> keys;
    keys.reserve(map.size());
    for (const auto& entry : map) {
      keys.push_back(entry.first);
    }
    return keys;
  }
  inline std::string get_std__unordered_map_std__string__std__string__value(const std__unordered_map_std__string__std__string_& map, const std::string& key) noexcept {
    return map.find(key)->second;
  }
  inline void emplace_std__unordered_map_std__string__std__string_(std__unordered_map_std__string__std__string_& map, const std::string& key, const std::string& value) noexcept {
    map.emplace(key, value);
  }
  
  // pragma MARK: std::variant<nitro::NullType, std::unordered_map<std::string, std::string>>
  /**
   * Wrapper struct for `std::variant<nitro::NullType, std::unordered_map<std::string, std::string>>`.
   * std::variant cannot be used in Swift because of a Swift bug.
   * Not even specializing it works. So we create a wrapper struct.
   */
  struct std__variant_nitro__NullType__std__unordered_map_std__string__std__string__ final {
    std::variant<nitro::NullType, std::unordered_map<std::string, std::string>> variant;
    std__variant_nitro__NullType__std__unordered_map_std__string__std__string__(std::variant<nitro::NullType, std::unordered_map<std::string, std::string>> variant): variant(variant) { }
    operator std::variant<nitro::NullType, std::unordered_map<std::string, std::string>>() const noexcept {
      return variant;
    }
    inline size_t index() const noexcept {
      return variant.index();
    }
    inline nitro::NullType get_0() const noexcept {
      return std::get<0>(variant);
    }
    inline std::unordered_map<std::string, std::string> get_1() const noexcept {
      return std::get<1>(variant);
    }
  };
  inline std__variant_nitro__NullType__std__unordered_map_std__string__std__string__ create_std__variant_nitro__NullType__std__unordered_map_std__string__std__string__(nitro::NullType value) noexcept {
    return std__variant_nitro__NullType__std__unordered_map_std__string__std__string__(value);
  }
  inline std__variant_nitro__NullType__std__unordered_map_std__string__std__string__ create_std__variant_nitro__NullType__std__unordered_map_std__string__std__string__(const std::unordered_map<std::string, std::string>& value) noexcept {
    return std__variant_nitro__NullType__std__unordered_map_std__string__std__string__(value);
  }
  
  // pragma MARK: std::optional<std::variant<nitro::NullType, std::unordered_map<std::string, std::string>>>
  /**
   * Specialized version of `std::optional<std::variant<nitro::NullType, std::unordered_map<std::string, std::string>>>`.
   */
  using std__optional_std__variant_nitro__NullType__std__unordered_map_std__string__std__string___ = std::optional<std::variant<nitro::NullType, std::unordered_map<std::string, std::string>>>;
  inline std::optional<std::variant<nitro::NullType, std::unordered_map<std::string, std::string>>> create_std__optional_std__variant_nitro__NullType__std__unordered_map_std__string__std__string___(const std::variant<nitro::NullType, std::unordered_map<std::string, std::string>>& value) noexcept {
    return std::optional<std::variant<nitro::NullType, std::unordered_map<std::string, std::string>>>(value);
  }
  inline bool has_value_std__optional_std__variant_nitro__NullType__std__unordered_map_std__string__std__string___(const std::optional<std::variant<nitro::NullType, std::unordered_map<std::string, std::string>>>& optional) noexcept {
    return optional.has_value();
  }
  inline std::variant<nitro::NullType, std::unordered_map<std::string, std::string>> get_std__optional_std__variant_nitro__NullType__std__unordered_map_std__string__std__string___(const std::optional<std::variant<nitro::NullType, std::unordered_map<std::string, std::string>>>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::variant<nitro::NullType, NitroRequestPurchaseIos>
  /**
   * Wrapper struct for `std::variant<nitro::NullType, NitroRequestPurchaseIos>`.
   * std::variant cannot be used in Swift because of a Swift bug.
   * Not even specializing it works. So we create a wrapper struct.
   */
  struct std__variant_nitro__NullType__NitroRequestPurchaseIos_ final {
    std::variant<nitro::NullType, NitroRequestPurchaseIos> variant;
    std__variant_nitro__NullType__NitroRequestPurchaseIos_(std::variant<nitro::NullType, NitroRequestPurchaseIos> variant): variant(variant) { }
    operator std::variant<nitro::NullType, NitroRequestPurchaseIos>() const noexcept {
      return variant;
    }
    inline size_t index() const noexcept {
      return variant.index();
    }
    inline nitro::NullType get_0() const noexcept {
      return std::get<0>(variant);
    }
    inline NitroRequestPurchaseIos get_1() const noexcept {
      return std::get<1>(variant);
    }
  };
  inline std__variant_nitro__NullType__NitroRequestPurchaseIos_ create_std__variant_nitro__NullType__NitroRequestPurchaseIos_(nitro::NullType value) noexcept {
    return std__variant_nitro__NullType__NitroRequestPurchaseIos_(value);
  }
  inline std__variant_nitro__NullType__NitroRequestPurchaseIos_ create_std__variant_nitro__NullType__NitroRequestPurchaseIos_(const NitroRequestPurchaseIos& value) noexcept {
    return std__variant_nitro__NullType__NitroRequestPurchaseIos_(value);
  }
  
  // pragma MARK: std::optional<std::variant<nitro::NullType, NitroRequestPurchaseIos>>
  /**
   * Specialized version of `std::optional<std::variant<nitro::NullType, NitroRequestPurchaseIos>>`.
   */
  using std__optional_std__variant_nitro__NullType__NitroRequestPurchaseIos__ = std::optional<std::variant<nitro::NullType, NitroRequestPurchaseIos>>;
  inline std::optional<std::variant<nitro::NullType, NitroRequestPurchaseIos>> create_std__optional_std__variant_nitro__NullType__NitroRequestPurchaseIos__(const std::variant<nitro::NullType, NitroRequestPurchaseIos>& value) noexcept {
    return std::optional<std::variant<nitro::NullType, NitroRequestPurchaseIos>>(value);
  }
  inline bool has_value_std__optional_std__variant_nitro__NullType__NitroRequestPurchaseIos__(const std::optional<std::variant<nitro::NullType, NitroRequestPurchaseIos>>& optional) noexcept {
    return optional.has_value();
  }
  inline std::variant<nitro::NullType, NitroRequestPurchaseIos> get_std__optional_std__variant_nitro__NullType__NitroRequestPurchaseIos__(const std::optional<std::variant<nitro::NullType, NitroRequestPurchaseIos>>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::vector<AndroidSubscriptionOfferInput>
  /**
   * Specialized version of `std::vector<AndroidSubscriptionOfferInput>`.
   */
  using std__vector_AndroidSubscriptionOfferInput_ = std::vector<AndroidSubscriptionOfferInput>;
  inline std::vector<AndroidSubscriptionOfferInput> create_std__vector_AndroidSubscriptionOfferInput_(size_t size) noexcept {
    std::vector<AndroidSubscriptionOfferInput> vector;
    vector.reserve(size);
    return vector;
  }
  
  // pragma MARK: std::variant<nitro::NullType, std::vector<AndroidSubscriptionOfferInput>>
  /**
   * Wrapper struct for `std::variant<nitro::NullType, std::vector<AndroidSubscriptionOfferInput>>`.
   * std::variant cannot be used in Swift because of a Swift bug.
   * Not even specializing it works. So we create a wrapper struct.
   */
  struct std__variant_nitro__NullType__std__vector_AndroidSubscriptionOfferInput__ final {
    std::variant<nitro::NullType, std::vector<AndroidSubscriptionOfferInput>> variant;
    std__variant_nitro__NullType__std__vector_AndroidSubscriptionOfferInput__(std::variant<nitro::NullType, std::vector<AndroidSubscriptionOfferInput>> variant): variant(variant) { }
    operator std::variant<nitro::NullType, std::vector<AndroidSubscriptionOfferInput>>() const noexcept {
      return variant;
    }
    inline size_t index() const noexcept {
      return variant.index();
    }
    inline nitro::NullType get_0() const noexcept {
      return std::get<0>(variant);
    }
    inline std::vector<AndroidSubscriptionOfferInput> get_1() const noexcept {
      return std::get<1>(variant);
    }
  };
  inline std__variant_nitro__NullType__std__vector_AndroidSubscriptionOfferInput__ create_std__variant_nitro__NullType__std__vector_AndroidSubscriptionOfferInput__(nitro::NullType value) noexcept {
    return std__variant_nitro__NullType__std__vector_AndroidSubscriptionOfferInput__(value);
  }
  inline std__variant_nitro__NullType__std__vector_AndroidSubscriptionOfferInput__ create_std__variant_nitro__NullType__std__vector_AndroidSubscriptionOfferInput__(const std::vector<AndroidSubscriptionOfferInput>& value) noexcept {
    return std__variant_nitro__NullType__std__vector_AndroidSubscriptionOfferInput__(value);
  }
  
  // pragma MARK: std::optional<std::variant<nitro::NullType, std::vector<AndroidSubscriptionOfferInput>>>
  /**
   * Specialized version of `std::optional<std::variant<nitro::NullType, std::vector<AndroidSubscriptionOfferInput>>>`.
   */
  using std__optional_std__variant_nitro__NullType__std__vector_AndroidSubscriptionOfferInput___ = std::optional<std::variant<nitro::NullType, std::vector<AndroidSubscriptionOfferInput>>>;
  inline std::optional<std::variant<nitro::NullType, std::vector<AndroidSubscriptionOfferInput>>> create_std__optional_std__variant_nitro__NullType__std__vector_AndroidSubscriptionOfferInput___(const std::variant<nitro::NullType, std::vector<AndroidSubscriptionOfferInput>>& value) noexcept {
    return std::optional<std::variant<nitro::NullType, std::vector<AndroidSubscriptionOfferInput>>>(value);
  }
  inline bool has_value_std__optional_std__variant_nitro__NullType__std__vector_AndroidSubscriptionOfferInput___(const std::optional<std::variant<nitro::NullType, std::vector<AndroidSubscriptionOfferInput>>>& optional) noexcept {
    return optional.has_value();
  }
  inline std::variant<nitro::NullType, std::vector<AndroidSubscriptionOfferInput>> get_std__optional_std__variant_nitro__NullType__std__vector_AndroidSubscriptionOfferInput___(const std::optional<std::variant<nitro::NullType, std::vector<AndroidSubscriptionOfferInput>>>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::variant<nitro::NullType, NitroRequestPurchaseAndroid>
  /**
   * Wrapper struct for `std::variant<nitro::NullType, NitroRequestPurchaseAndroid>`.
   * std::variant cannot be used in Swift because of a Swift bug.
   * Not even specializing it works. So we create a wrapper struct.
   */
  struct std__variant_nitro__NullType__NitroRequestPurchaseAndroid_ final {
    std::variant<nitro::NullType, NitroRequestPurchaseAndroid> variant;
    std__variant_nitro__NullType__NitroRequestPurchaseAndroid_(std::variant<nitro::NullType, NitroRequestPurchaseAndroid> variant): variant(variant) { }
    operator std::variant<nitro::NullType, NitroRequestPurchaseAndroid>() const noexcept {
      return variant;
    }
    inline size_t index() const noexcept {
      return variant.index();
    }
    inline nitro::NullType get_0() const noexcept {
      return std::get<0>(variant);
    }
    inline NitroRequestPurchaseAndroid get_1() const noexcept {
      return std::get<1>(variant);
    }
  };
  inline std__variant_nitro__NullType__NitroRequestPurchaseAndroid_ create_std__variant_nitro__NullType__NitroRequestPurchaseAndroid_(nitro::NullType value) noexcept {
    return std__variant_nitro__NullType__NitroRequestPurchaseAndroid_(value);
  }
  inline std__variant_nitro__NullType__NitroRequestPurchaseAndroid_ create_std__variant_nitro__NullType__NitroRequestPurchaseAndroid_(const NitroRequestPurchaseAndroid& value) noexcept {
    return std__variant_nitro__NullType__NitroRequestPurchaseAndroid_(value);
  }
  
  // pragma MARK: std::optional<std::variant<nitro::NullType, NitroRequestPurchaseAndroid>>
  /**
   * Specialized version of `std::optional<std::variant<nitro::NullType, NitroRequestPurchaseAndroid>>`.
   */
  using std__optional_std__variant_nitro__NullType__NitroRequestPurchaseAndroid__ = std::optional<std::variant<nitro::NullType, NitroRequestPurchaseAndroid>>;
  inline std::optional<std::variant<nitro::NullType, NitroRequestPurchaseAndroid>> create_std__optional_std__variant_nitro__NullType__NitroRequestPurchaseAndroid__(const std::variant<nitro::NullType, NitroRequestPurchaseAndroid>& value) noexcept {
    return std::optional<std::variant<nitro::NullType, NitroRequestPurchaseAndroid>>(value);
  }
  inline bool has_value_std__optional_std__variant_nitro__NullType__NitroRequestPurchaseAndroid__(const std::optional<std::variant<nitro::NullType, NitroRequestPurchaseAndroid>>& optional) noexcept {
    return optional.has_value();
  }
  inline std::variant<nitro::NullType, NitroRequestPurchaseAndroid> get_std__optional_std__variant_nitro__NullType__NitroRequestPurchaseAndroid__(const std::optional<std::variant<nitro::NullType, NitroRequestPurchaseAndroid>>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::variant<nitro::NullType, NitroRenewalInfoIOS>
  /**
   * Wrapper struct for `std::variant<nitro::NullType, NitroRenewalInfoIOS>`.
   * std::variant cannot be used in Swift because of a Swift bug.
   * Not even specializing it works. So we create a wrapper struct.
   */
  struct std__variant_nitro__NullType__NitroRenewalInfoIOS_ final {
    std::variant<nitro::NullType, NitroRenewalInfoIOS> variant;
    std__variant_nitro__NullType__NitroRenewalInfoIOS_(std::variant<nitro::NullType, NitroRenewalInfoIOS> variant): variant(variant) { }
    operator std::variant<nitro::NullType, NitroRenewalInfoIOS>() const noexcept {
      return variant;
    }
    inline size_t index() const noexcept {
      return variant.index();
    }
    inline nitro::NullType get_0() const noexcept {
      return std::get<0>(variant);
    }
    inline NitroRenewalInfoIOS get_1() const noexcept {
      return std::get<1>(variant);
    }
  };
  inline std__variant_nitro__NullType__NitroRenewalInfoIOS_ create_std__variant_nitro__NullType__NitroRenewalInfoIOS_(nitro::NullType value) noexcept {
    return std__variant_nitro__NullType__NitroRenewalInfoIOS_(value);
  }
  inline std__variant_nitro__NullType__NitroRenewalInfoIOS_ create_std__variant_nitro__NullType__NitroRenewalInfoIOS_(const NitroRenewalInfoIOS& value) noexcept {
    return std__variant_nitro__NullType__NitroRenewalInfoIOS_(value);
  }
  
  // pragma MARK: std::optional<std::variant<nitro::NullType, NitroRenewalInfoIOS>>
  /**
   * Specialized version of `std::optional<std::variant<nitro::NullType, NitroRenewalInfoIOS>>`.
   */
  using std__optional_std__variant_nitro__NullType__NitroRenewalInfoIOS__ = std::optional<std::variant<nitro::NullType, NitroRenewalInfoIOS>>;
  inline std::optional<std::variant<nitro::NullType, NitroRenewalInfoIOS>> create_std__optional_std__variant_nitro__NullType__NitroRenewalInfoIOS__(const std::variant<nitro::NullType, NitroRenewalInfoIOS>& value) noexcept {
    return std::optional<std::variant<nitro::NullType, NitroRenewalInfoIOS>>(value);
  }
  inline bool has_value_std__optional_std__variant_nitro__NullType__NitroRenewalInfoIOS__(const std::optional<std::variant<nitro::NullType, NitroRenewalInfoIOS>>& optional) noexcept {
    return optional.has_value();
  }
  inline std::variant<nitro::NullType, NitroRenewalInfoIOS> get_std__optional_std__variant_nitro__NullType__NitroRenewalInfoIOS__(const std::optional<std::variant<nitro::NullType, NitroRenewalInfoIOS>>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::vector<NitroPurchase>
  /**
   * Specialized version of `std::vector<NitroPurchase>`.
   */
  using std__vector_NitroPurchase_ = std::vector<NitroPurchase>;
  inline std::vector<NitroPurchase> create_std__vector_NitroPurchase_(size_t size) noexcept {
    std::vector<NitroPurchase> vector;
    vector.reserve(size);
    return vector;
  }
  
  // pragma MARK: std::shared_ptr<Promise<std::vector<NitroPurchase>>>
  /**
   * Specialized version of `std::shared_ptr<Promise<std::vector<NitroPurchase>>>`.
   */
  using std__shared_ptr_Promise_std__vector_NitroPurchase___ = std::shared_ptr<Promise<std::vector<NitroPurchase>>>;
  inline std::shared_ptr<Promise<std::vector<NitroPurchase>>> create_std__shared_ptr_Promise_std__vector_NitroPurchase___() noexcept {
    return Promise<std::vector<NitroPurchase>>::create();
  }
  inline PromiseHolder<std::vector<NitroPurchase>> wrap_std__shared_ptr_Promise_std__vector_NitroPurchase___(std::shared_ptr<Promise<std::vector<NitroPurchase>>> promise) noexcept {
    return PromiseHolder<std::vector<NitroPurchase>>(std::move(promise));
  }
  
  // pragma MARK: std::function<void(const std::vector<NitroPurchase>& /* result */)>
  /**
   * Specialized version of `std::function<void(const std::vector<NitroPurchase>&)>`.
   */
  using Func_void_std__vector_NitroPurchase_ = std::function<void(const std::vector<NitroPurchase>& /* result */)>;
  /**
   * Wrapper class for a `std::function<void(const std::vector<NitroPurchase>& / * result * /)>`, this can be used from Swift.
   */
  class Func_void_std__vector_NitroPurchase__Wrapper final {
  public:
    explicit Func_void_std__vector_NitroPurchase__Wrapper(std::function<void(const std::vector<NitroPurchase>& /* result */)>&& func): _function(std::make_unique<std::function<void(const std::vector<NitroPurchase>& /* result */)>>(std::move(func))) {}
    inline void call(std::vector<NitroPurchase> result) const noexcept {
      _function->operator()(result);
    }
  private:
    std::unique_ptr<std::function<void(const std::vector<NitroPurchase>& /* result */)>> _function;
  } SWIFT_NONCOPYABLE;
  Func_void_std__vector_NitroPurchase_ create_Func_void_std__vector_NitroPurchase_(void* NON_NULL swiftClosureWrapper) noexcept;
  inline Func_void_std__vector_NitroPurchase__Wrapper wrap_Func_void_std__vector_NitroPurchase_(Func_void_std__vector_NitroPurchase_ value) noexcept {
    return Func_void_std__vector_NitroPurchase__Wrapper(std::move(value));
  }
  
  // pragma MARK: std::variant<nitro::NullType, NitroAvailablePurchasesIosOptions>
  /**
   * Wrapper struct for `std::variant<nitro::NullType, NitroAvailablePurchasesIosOptions>`.
   * std::variant cannot be used in Swift because of a Swift bug.
   * Not even specializing it works. So we create a wrapper struct.
   */
  struct std__variant_nitro__NullType__NitroAvailablePurchasesIosOptions_ final {
    std::variant<nitro::NullType, NitroAvailablePurchasesIosOptions> variant;
    std__variant_nitro__NullType__NitroAvailablePurchasesIosOptions_(std::variant<nitro::NullType, NitroAvailablePurchasesIosOptions> variant): variant(variant) { }
    operator std::variant<nitro::NullType, NitroAvailablePurchasesIosOptions>() const noexcept {
      return variant;
    }
    inline size_t index() const noexcept {
      return variant.index();
    }
    inline nitro::NullType get_0() const noexcept {
      return std::get<0>(variant);
    }
    inline NitroAvailablePurchasesIosOptions get_1() const noexcept {
      return std::get<1>(variant);
    }
  };
  inline std__variant_nitro__NullType__NitroAvailablePurchasesIosOptions_ create_std__variant_nitro__NullType__NitroAvailablePurchasesIosOptions_(nitro::NullType value) noexcept {
    return std__variant_nitro__NullType__NitroAvailablePurchasesIosOptions_(value);
  }
  inline std__variant_nitro__NullType__NitroAvailablePurchasesIosOptions_ create_std__variant_nitro__NullType__NitroAvailablePurchasesIosOptions_(const NitroAvailablePurchasesIosOptions& value) noexcept {
    return std__variant_nitro__NullType__NitroAvailablePurchasesIosOptions_(value);
  }
  
  // pragma MARK: std::optional<std::variant<nitro::NullType, NitroAvailablePurchasesIosOptions>>
  /**
   * Specialized version of `std::optional<std::variant<nitro::NullType, NitroAvailablePurchasesIosOptions>>`.
   */
  using std__optional_std__variant_nitro__NullType__NitroAvailablePurchasesIosOptions__ = std::optional<std::variant<nitro::NullType, NitroAvailablePurchasesIosOptions>>;
  inline std::optional<std::variant<nitro::NullType, NitroAvailablePurchasesIosOptions>> create_std__optional_std__variant_nitro__NullType__NitroAvailablePurchasesIosOptions__(const std::variant<nitro::NullType, NitroAvailablePurchasesIosOptions>& value) noexcept {
    return std::optional<std::variant<nitro::NullType, NitroAvailablePurchasesIosOptions>>(value);
  }
  inline bool has_value_std__optional_std__variant_nitro__NullType__NitroAvailablePurchasesIosOptions__(const std::optional<std::variant<nitro::NullType, NitroAvailablePurchasesIosOptions>>& optional) noexcept {
    return optional.has_value();
  }
  inline std::variant<nitro::NullType, NitroAvailablePurchasesIosOptions> get_std__optional_std__variant_nitro__NullType__NitroAvailablePurchasesIosOptions__(const std::optional<std::variant<nitro::NullType, NitroAvailablePurchasesIosOptions>>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::optional<NitroAvailablePurchasesAndroidType>
  /**
   * Specialized version of `std::optional<NitroAvailablePurchasesAndroidType>`.
   */
  using std__optional_NitroAvailablePurchasesAndroidType_ = std::optional<NitroAvailablePurchasesAndroidType>;
  inline std::optional<NitroAvailablePurchasesAndroidType> create_std__optional_NitroAvailablePurchasesAndroidType_(const NitroAvailablePurchasesAndroidType& value) noexcept {
    return std::optional<NitroAvailablePurchasesAndroidType>(value);
  }
  inline bool has_value_std__optional_NitroAvailablePurchasesAndroidType_(const std::optional<NitroAvailablePurchasesAndroidType>& optional) noexcept {
    return optional.has_value();
  }
  inline NitroAvailablePurchasesAndroidType get_std__optional_NitroAvailablePurchasesAndroidType_(const std::optional<NitroAvailablePurchasesAndroidType>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::variant<nitro::NullType, NitroAvailablePurchasesAndroidOptions>
  /**
   * Wrapper struct for `std::variant<nitro::NullType, NitroAvailablePurchasesAndroidOptions>`.
   * std::variant cannot be used in Swift because of a Swift bug.
   * Not even specializing it works. So we create a wrapper struct.
   */
  struct std__variant_nitro__NullType__NitroAvailablePurchasesAndroidOptions_ final {
    std::variant<nitro::NullType, NitroAvailablePurchasesAndroidOptions> variant;
    std__variant_nitro__NullType__NitroAvailablePurchasesAndroidOptions_(std::variant<nitro::NullType, NitroAvailablePurchasesAndroidOptions> variant): variant(variant) { }
    operator std::variant<nitro::NullType, NitroAvailablePurchasesAndroidOptions>() const noexcept {
      return variant;
    }
    inline size_t index() const noexcept {
      return variant.index();
    }
    inline nitro::NullType get_0() const noexcept {
      return std::get<0>(variant);
    }
    inline NitroAvailablePurchasesAndroidOptions get_1() const noexcept {
      return std::get<1>(variant);
    }
  };
  inline std__variant_nitro__NullType__NitroAvailablePurchasesAndroidOptions_ create_std__variant_nitro__NullType__NitroAvailablePurchasesAndroidOptions_(nitro::NullType value) noexcept {
    return std__variant_nitro__NullType__NitroAvailablePurchasesAndroidOptions_(value);
  }
  inline std__variant_nitro__NullType__NitroAvailablePurchasesAndroidOptions_ create_std__variant_nitro__NullType__NitroAvailablePurchasesAndroidOptions_(const NitroAvailablePurchasesAndroidOptions& value) noexcept {
    return std__variant_nitro__NullType__NitroAvailablePurchasesAndroidOptions_(value);
  }
  
  // pragma MARK: std::optional<std::variant<nitro::NullType, NitroAvailablePurchasesAndroidOptions>>
  /**
   * Specialized version of `std::optional<std::variant<nitro::NullType, NitroAvailablePurchasesAndroidOptions>>`.
   */
  using std__optional_std__variant_nitro__NullType__NitroAvailablePurchasesAndroidOptions__ = std::optional<std::variant<nitro::NullType, NitroAvailablePurchasesAndroidOptions>>;
  inline std::optional<std::variant<nitro::NullType, NitroAvailablePurchasesAndroidOptions>> create_std__optional_std__variant_nitro__NullType__NitroAvailablePurchasesAndroidOptions__(const std::variant<nitro::NullType, NitroAvailablePurchasesAndroidOptions>& value) noexcept {
    return std::optional<std::variant<nitro::NullType, NitroAvailablePurchasesAndroidOptions>>(value);
  }
  inline bool has_value_std__optional_std__variant_nitro__NullType__NitroAvailablePurchasesAndroidOptions__(const std::optional<std::variant<nitro::NullType, NitroAvailablePurchasesAndroidOptions>>& optional) noexcept {
    return optional.has_value();
  }
  inline std::variant<nitro::NullType, NitroAvailablePurchasesAndroidOptions> get_std__optional_std__variant_nitro__NullType__NitroAvailablePurchasesAndroidOptions__(const std::optional<std::variant<nitro::NullType, NitroAvailablePurchasesAndroidOptions>>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::optional<NitroAvailablePurchasesOptions>
  /**
   * Specialized version of `std::optional<NitroAvailablePurchasesOptions>`.
   */
  using std__optional_NitroAvailablePurchasesOptions_ = std::optional<NitroAvailablePurchasesOptions>;
  inline std::optional<NitroAvailablePurchasesOptions> create_std__optional_NitroAvailablePurchasesOptions_(const NitroAvailablePurchasesOptions& value) noexcept {
    return std::optional<NitroAvailablePurchasesOptions>(value);
  }
  inline bool has_value_std__optional_NitroAvailablePurchasesOptions_(const std::optional<NitroAvailablePurchasesOptions>& optional) noexcept {
    return optional.has_value();
  }
  inline NitroAvailablePurchasesOptions get_std__optional_NitroAvailablePurchasesOptions_(const std::optional<NitroAvailablePurchasesOptions>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::vector<NitroActiveSubscription>
  /**
   * Specialized version of `std::vector<NitroActiveSubscription>`.
   */
  using std__vector_NitroActiveSubscription_ = std::vector<NitroActiveSubscription>;
  inline std::vector<NitroActiveSubscription> create_std__vector_NitroActiveSubscription_(size_t size) noexcept {
    std::vector<NitroActiveSubscription> vector;
    vector.reserve(size);
    return vector;
  }
  
  // pragma MARK: std::shared_ptr<Promise<std::vector<NitroActiveSubscription>>>
  /**
   * Specialized version of `std::shared_ptr<Promise<std::vector<NitroActiveSubscription>>>`.
   */
  using std__shared_ptr_Promise_std__vector_NitroActiveSubscription___ = std::shared_ptr<Promise<std::vector<NitroActiveSubscription>>>;
  inline std::shared_ptr<Promise<std::vector<NitroActiveSubscription>>> create_std__shared_ptr_Promise_std__vector_NitroActiveSubscription___() noexcept {
    return Promise<std::vector<NitroActiveSubscription>>::create();
  }
  inline PromiseHolder<std::vector<NitroActiveSubscription>> wrap_std__shared_ptr_Promise_std__vector_NitroActiveSubscription___(std::shared_ptr<Promise<std::vector<NitroActiveSubscription>>> promise) noexcept {
    return PromiseHolder<std::vector<NitroActiveSubscription>>(std::move(promise));
  }
  
  // pragma MARK: std::function<void(const std::vector<NitroActiveSubscription>& /* result */)>
  /**
   * Specialized version of `std::function<void(const std::vector<NitroActiveSubscription>&)>`.
   */
  using Func_void_std__vector_NitroActiveSubscription_ = std::function<void(const std::vector<NitroActiveSubscription>& /* result */)>;
  /**
   * Wrapper class for a `std::function<void(const std::vector<NitroActiveSubscription>& / * result * /)>`, this can be used from Swift.
   */
  class Func_void_std__vector_NitroActiveSubscription__Wrapper final {
  public:
    explicit Func_void_std__vector_NitroActiveSubscription__Wrapper(std::function<void(const std::vector<NitroActiveSubscription>& /* result */)>&& func): _function(std::make_unique<std::function<void(const std::vector<NitroActiveSubscription>& /* result */)>>(std::move(func))) {}
    inline void call(std::vector<NitroActiveSubscription> result) const noexcept {
      _function->operator()(result);
    }
  private:
    std::unique_ptr<std::function<void(const std::vector<NitroActiveSubscription>& /* result */)>> _function;
  } SWIFT_NONCOPYABLE;
  Func_void_std__vector_NitroActiveSubscription_ create_Func_void_std__vector_NitroActiveSubscription_(void* NON_NULL swiftClosureWrapper) noexcept;
  inline Func_void_std__vector_NitroActiveSubscription__Wrapper wrap_Func_void_std__vector_NitroActiveSubscription_(Func_void_std__vector_NitroActiveSubscription_ value) noexcept {
    return Func_void_std__vector_NitroActiveSubscription__Wrapper(std::move(value));
  }
  
  // pragma MARK: std::optional<std::vector<std::string>>
  /**
   * Specialized version of `std::optional<std::vector<std::string>>`.
   */
  using std__optional_std__vector_std__string__ = std::optional<std::vector<std::string>>;
  inline std::optional<std::vector<std::string>> create_std__optional_std__vector_std__string__(const std::vector<std::string>& value) noexcept {
    return std::optional<std::vector<std::string>>(value);
  }
  inline bool has_value_std__optional_std__vector_std__string__(const std::optional<std::vector<std::string>>& optional) noexcept {
    return optional.has_value();
  }
  inline std::vector<std::string> get_std__optional_std__vector_std__string__(const std::optional<std::vector<std::string>>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::variant<bool, NitroPurchaseResult>
  /**
   * Wrapper struct for `std::variant<bool, NitroPurchaseResult>`.
   * std::variant cannot be used in Swift because of a Swift bug.
   * Not even specializing it works. So we create a wrapper struct.
   */
  struct std__variant_bool__NitroPurchaseResult_ final {
    std::variant<bool, NitroPurchaseResult> variant;
    std__variant_bool__NitroPurchaseResult_(std::variant<bool, NitroPurchaseResult> variant): variant(variant) { }
    operator std::variant<bool, NitroPurchaseResult>() const noexcept {
      return variant;
    }
    inline size_t index() const noexcept {
      return variant.index();
    }
    inline bool get_0() const noexcept {
      return std::get<0>(variant);
    }
    inline NitroPurchaseResult get_1() const noexcept {
      return std::get<1>(variant);
    }
  };
  inline std__variant_bool__NitroPurchaseResult_ create_std__variant_bool__NitroPurchaseResult_(bool value) noexcept {
    return std__variant_bool__NitroPurchaseResult_(value);
  }
  inline std__variant_bool__NitroPurchaseResult_ create_std__variant_bool__NitroPurchaseResult_(const NitroPurchaseResult& value) noexcept {
    return std__variant_bool__NitroPurchaseResult_(value);
  }
  
  // pragma MARK: std::shared_ptr<Promise<std::variant<bool, NitroPurchaseResult>>>
  /**
   * Specialized version of `std::shared_ptr<Promise<std::variant<bool, NitroPurchaseResult>>>`.
   */
  using std__shared_ptr_Promise_std__variant_bool__NitroPurchaseResult___ = std::shared_ptr<Promise<std::variant<bool, NitroPurchaseResult>>>;
  inline std::shared_ptr<Promise<std::variant<bool, NitroPurchaseResult>>> create_std__shared_ptr_Promise_std__variant_bool__NitroPurchaseResult___() noexcept {
    return Promise<std::variant<bool, NitroPurchaseResult>>::create();
  }
  inline PromiseHolder<std::variant<bool, NitroPurchaseResult>> wrap_std__shared_ptr_Promise_std__variant_bool__NitroPurchaseResult___(std::shared_ptr<Promise<std::variant<bool, NitroPurchaseResult>>> promise) noexcept {
    return PromiseHolder<std::variant<bool, NitroPurchaseResult>>(std::move(promise));
  }
  
  // pragma MARK: std::function<void(const std::variant<bool, NitroPurchaseResult>& /* result */)>
  /**
   * Specialized version of `std::function<void(const std::variant<bool, NitroPurchaseResult>&)>`.
   */
  using Func_void_std__variant_bool__NitroPurchaseResult_ = std::function<void(const std::variant<bool, NitroPurchaseResult>& /* result */)>;
  /**
   * Wrapper class for a `std::function<void(const std::variant<bool, NitroPurchaseResult>& / * result * /)>`, this can be used from Swift.
   */
  class Func_void_std__variant_bool__NitroPurchaseResult__Wrapper final {
  public:
    explicit Func_void_std__variant_bool__NitroPurchaseResult__Wrapper(std::function<void(const std::variant<bool, NitroPurchaseResult>& /* result */)>&& func): _function(std::make_unique<std::function<void(const std::variant<bool, NitroPurchaseResult>& /* result */)>>(std::move(func))) {}
    inline void call(std::variant<bool, NitroPurchaseResult> result) const noexcept {
      _function->operator()(result);
    }
  private:
    std::unique_ptr<std::function<void(const std::variant<bool, NitroPurchaseResult>& /* result */)>> _function;
  } SWIFT_NONCOPYABLE;
  Func_void_std__variant_bool__NitroPurchaseResult_ create_Func_void_std__variant_bool__NitroPurchaseResult_(void* NON_NULL swiftClosureWrapper) noexcept;
  inline Func_void_std__variant_bool__NitroPurchaseResult__Wrapper wrap_Func_void_std__variant_bool__NitroPurchaseResult_(Func_void_std__variant_bool__NitroPurchaseResult_ value) noexcept {
    return Func_void_std__variant_bool__NitroPurchaseResult__Wrapper(std::move(value));
  }
  
  // pragma MARK: std::variant<nitro::NullType, NitroFinishTransactionIosParams>
  /**
   * Wrapper struct for `std::variant<nitro::NullType, NitroFinishTransactionIosParams>`.
   * std::variant cannot be used in Swift because of a Swift bug.
   * Not even specializing it works. So we create a wrapper struct.
   */
  struct std__variant_nitro__NullType__NitroFinishTransactionIosParams_ final {
    std::variant<nitro::NullType, NitroFinishTransactionIosParams> variant;
    std__variant_nitro__NullType__NitroFinishTransactionIosParams_(std::variant<nitro::NullType, NitroFinishTransactionIosParams> variant): variant(variant) { }
    operator std::variant<nitro::NullType, NitroFinishTransactionIosParams>() const noexcept {
      return variant;
    }
    inline size_t index() const noexcept {
      return variant.index();
    }
    inline nitro::NullType get_0() const noexcept {
      return std::get<0>(variant);
    }
    inline NitroFinishTransactionIosParams get_1() const noexcept {
      return std::get<1>(variant);
    }
  };
  inline std__variant_nitro__NullType__NitroFinishTransactionIosParams_ create_std__variant_nitro__NullType__NitroFinishTransactionIosParams_(nitro::NullType value) noexcept {
    return std__variant_nitro__NullType__NitroFinishTransactionIosParams_(value);
  }
  inline std__variant_nitro__NullType__NitroFinishTransactionIosParams_ create_std__variant_nitro__NullType__NitroFinishTransactionIosParams_(const NitroFinishTransactionIosParams& value) noexcept {
    return std__variant_nitro__NullType__NitroFinishTransactionIosParams_(value);
  }
  
  // pragma MARK: std::optional<std::variant<nitro::NullType, NitroFinishTransactionIosParams>>
  /**
   * Specialized version of `std::optional<std::variant<nitro::NullType, NitroFinishTransactionIosParams>>`.
   */
  using std__optional_std__variant_nitro__NullType__NitroFinishTransactionIosParams__ = std::optional<std::variant<nitro::NullType, NitroFinishTransactionIosParams>>;
  inline std::optional<std::variant<nitro::NullType, NitroFinishTransactionIosParams>> create_std__optional_std__variant_nitro__NullType__NitroFinishTransactionIosParams__(const std::variant<nitro::NullType, NitroFinishTransactionIosParams>& value) noexcept {
    return std::optional<std::variant<nitro::NullType, NitroFinishTransactionIosParams>>(value);
  }
  inline bool has_value_std__optional_std__variant_nitro__NullType__NitroFinishTransactionIosParams__(const std::optional<std::variant<nitro::NullType, NitroFinishTransactionIosParams>>& optional) noexcept {
    return optional.has_value();
  }
  inline std::variant<nitro::NullType, NitroFinishTransactionIosParams> get_std__optional_std__variant_nitro__NullType__NitroFinishTransactionIosParams__(const std::optional<std::variant<nitro::NullType, NitroFinishTransactionIosParams>>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::variant<nitro::NullType, NitroFinishTransactionAndroidParams>
  /**
   * Wrapper struct for `std::variant<nitro::NullType, NitroFinishTransactionAndroidParams>`.
   * std::variant cannot be used in Swift because of a Swift bug.
   * Not even specializing it works. So we create a wrapper struct.
   */
  struct std__variant_nitro__NullType__NitroFinishTransactionAndroidParams_ final {
    std::variant<nitro::NullType, NitroFinishTransactionAndroidParams> variant;
    std__variant_nitro__NullType__NitroFinishTransactionAndroidParams_(std::variant<nitro::NullType, NitroFinishTransactionAndroidParams> variant): variant(variant) { }
    operator std::variant<nitro::NullType, NitroFinishTransactionAndroidParams>() const noexcept {
      return variant;
    }
    inline size_t index() const noexcept {
      return variant.index();
    }
    inline nitro::NullType get_0() const noexcept {
      return std::get<0>(variant);
    }
    inline NitroFinishTransactionAndroidParams get_1() const noexcept {
      return std::get<1>(variant);
    }
  };
  inline std__variant_nitro__NullType__NitroFinishTransactionAndroidParams_ create_std__variant_nitro__NullType__NitroFinishTransactionAndroidParams_(nitro::NullType value) noexcept {
    return std__variant_nitro__NullType__NitroFinishTransactionAndroidParams_(value);
  }
  inline std__variant_nitro__NullType__NitroFinishTransactionAndroidParams_ create_std__variant_nitro__NullType__NitroFinishTransactionAndroidParams_(const NitroFinishTransactionAndroidParams& value) noexcept {
    return std__variant_nitro__NullType__NitroFinishTransactionAndroidParams_(value);
  }
  
  // pragma MARK: std::optional<std::variant<nitro::NullType, NitroFinishTransactionAndroidParams>>
  /**
   * Specialized version of `std::optional<std::variant<nitro::NullType, NitroFinishTransactionAndroidParams>>`.
   */
  using std__optional_std__variant_nitro__NullType__NitroFinishTransactionAndroidParams__ = std::optional<std::variant<nitro::NullType, NitroFinishTransactionAndroidParams>>;
  inline std::optional<std::variant<nitro::NullType, NitroFinishTransactionAndroidParams>> create_std__optional_std__variant_nitro__NullType__NitroFinishTransactionAndroidParams__(const std::variant<nitro::NullType, NitroFinishTransactionAndroidParams>& value) noexcept {
    return std::optional<std::variant<nitro::NullType, NitroFinishTransactionAndroidParams>>(value);
  }
  inline bool has_value_std__optional_std__variant_nitro__NullType__NitroFinishTransactionAndroidParams__(const std::optional<std::variant<nitro::NullType, NitroFinishTransactionAndroidParams>>& optional) noexcept {
    return optional.has_value();
  }
  inline std::variant<nitro::NullType, NitroFinishTransactionAndroidParams> get_std__optional_std__variant_nitro__NullType__NitroFinishTransactionAndroidParams__(const std::optional<std::variant<nitro::NullType, NitroFinishTransactionAndroidParams>>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::function<void(const NitroPurchase& /* purchase */)>
  /**
   * Specialized version of `std::function<void(const NitroPurchase&)>`.
   */
  using Func_void_NitroPurchase = std::function<void(const NitroPurchase& /* purchase */)>;
  /**
   * Wrapper class for a `std::function<void(const NitroPurchase& / * purchase * /)>`, this can be used from Swift.
   */
  class Func_void_NitroPurchase_Wrapper final {
  public:
    explicit Func_void_NitroPurchase_Wrapper(std::function<void(const NitroPurchase& /* purchase */)>&& func): _function(std::make_unique<std::function<void(const NitroPurchase& /* purchase */)>>(std::move(func))) {}
    inline void call(NitroPurchase purchase) const noexcept {
      _function->operator()(purchase);
    }
  private:
    std::unique_ptr<std::function<void(const NitroPurchase& /* purchase */)>> _function;
  } SWIFT_NONCOPYABLE;
  Func_void_NitroPurchase create_Func_void_NitroPurchase(void* NON_NULL swiftClosureWrapper) noexcept;
  inline Func_void_NitroPurchase_Wrapper wrap_Func_void_NitroPurchase(Func_void_NitroPurchase value) noexcept {
    return Func_void_NitroPurchase_Wrapper(std::move(value));
  }
  
  // pragma MARK: std::function<void(const NitroPurchaseResult& /* error */)>
  /**
   * Specialized version of `std::function<void(const NitroPurchaseResult&)>`.
   */
  using Func_void_NitroPurchaseResult = std::function<void(const NitroPurchaseResult& /* error */)>;
  /**
   * Wrapper class for a `std::function<void(const NitroPurchaseResult& / * error * /)>`, this can be used from Swift.
   */
  class Func_void_NitroPurchaseResult_Wrapper final {
  public:
    explicit Func_void_NitroPurchaseResult_Wrapper(std::function<void(const NitroPurchaseResult& /* error */)>&& func): _function(std::make_unique<std::function<void(const NitroPurchaseResult& /* error */)>>(std::move(func))) {}
    inline void call(NitroPurchaseResult error) const noexcept {
      _function->operator()(error);
    }
  private:
    std::unique_ptr<std::function<void(const NitroPurchaseResult& /* error */)>> _function;
  } SWIFT_NONCOPYABLE;
  Func_void_NitroPurchaseResult create_Func_void_NitroPurchaseResult(void* NON_NULL swiftClosureWrapper) noexcept;
  inline Func_void_NitroPurchaseResult_Wrapper wrap_Func_void_NitroPurchaseResult(Func_void_NitroPurchaseResult value) noexcept {
    return Func_void_NitroPurchaseResult_Wrapper(std::move(value));
  }
  
  // pragma MARK: std::function<void(const NitroProduct& /* product */)>
  /**
   * Specialized version of `std::function<void(const NitroProduct&)>`.
   */
  using Func_void_NitroProduct = std::function<void(const NitroProduct& /* product */)>;
  /**
   * Wrapper class for a `std::function<void(const NitroProduct& / * product * /)>`, this can be used from Swift.
   */
  class Func_void_NitroProduct_Wrapper final {
  public:
    explicit Func_void_NitroProduct_Wrapper(std::function<void(const NitroProduct& /* product */)>&& func): _function(std::make_unique<std::function<void(const NitroProduct& /* product */)>>(std::move(func))) {}
    inline void call(NitroProduct product) const noexcept {
      _function->operator()(product);
    }
  private:
    std::unique_ptr<std::function<void(const NitroProduct& /* product */)>> _function;
  } SWIFT_NONCOPYABLE;
  Func_void_NitroProduct create_Func_void_NitroProduct(void* NON_NULL swiftClosureWrapper) noexcept;
  inline Func_void_NitroProduct_Wrapper wrap_Func_void_NitroProduct(Func_void_NitroProduct value) noexcept {
    return Func_void_NitroProduct_Wrapper(std::move(value));
  }
  
  // pragma MARK: std::shared_ptr<Promise<std::string>>
  /**
   * Specialized version of `std::shared_ptr<Promise<std::string>>`.
   */
  using std__shared_ptr_Promise_std__string__ = std::shared_ptr<Promise<std::string>>;
  inline std::shared_ptr<Promise<std::string>> create_std__shared_ptr_Promise_std__string__() noexcept {
    return Promise<std::string>::create();
  }
  inline PromiseHolder<std::string> wrap_std__shared_ptr_Promise_std__string__(std::shared_ptr<Promise<std::string>> promise) noexcept {
    return PromiseHolder<std::string>(std::move(promise));
  }
  
  // pragma MARK: std::function<void(const std::string& /* result */)>
  /**
   * Specialized version of `std::function<void(const std::string&)>`.
   */
  using Func_void_std__string = std::function<void(const std::string& /* result */)>;
  /**
   * Wrapper class for a `std::function<void(const std::string& / * result * /)>`, this can be used from Swift.
   */
  class Func_void_std__string_Wrapper final {
  public:
    explicit Func_void_std__string_Wrapper(std::function<void(const std::string& /* result */)>&& func): _function(std::make_unique<std::function<void(const std::string& /* result */)>>(std::move(func))) {}
    inline void call(std::string result) const noexcept {
      _function->operator()(result);
    }
  private:
    std::unique_ptr<std::function<void(const std::string& /* result */)>> _function;
  } SWIFT_NONCOPYABLE;
  Func_void_std__string create_Func_void_std__string(void* NON_NULL swiftClosureWrapper) noexcept;
  inline Func_void_std__string_Wrapper wrap_Func_void_std__string(Func_void_std__string value) noexcept {
    return Func_void_std__string_Wrapper(std::move(value));
  }
  
  // pragma MARK: std::shared_ptr<Promise<std::variant<nitro::NullType, std::string>>>
  /**
   * Specialized version of `std::shared_ptr<Promise<std::variant<nitro::NullType, std::string>>>`.
   */
  using std__shared_ptr_Promise_std__variant_nitro__NullType__std__string___ = std::shared_ptr<Promise<std::variant<nitro::NullType, std::string>>>;
  inline std::shared_ptr<Promise<std::variant<nitro::NullType, std::string>>> create_std__shared_ptr_Promise_std__variant_nitro__NullType__std__string___() noexcept {
    return Promise<std::variant<nitro::NullType, std::string>>::create();
  }
  inline PromiseHolder<std::variant<nitro::NullType, std::string>> wrap_std__shared_ptr_Promise_std__variant_nitro__NullType__std__string___(std::shared_ptr<Promise<std::variant<nitro::NullType, std::string>>> promise) noexcept {
    return PromiseHolder<std::variant<nitro::NullType, std::string>>(std::move(promise));
  }
  
  // pragma MARK: std::function<void(const std::variant<nitro::NullType, std::string>& /* result */)>
  /**
   * Specialized version of `std::function<void(const std::variant<nitro::NullType, std::string>&)>`.
   */
  using Func_void_std__variant_nitro__NullType__std__string_ = std::function<void(const std::variant<nitro::NullType, std::string>& /* result */)>;
  /**
   * Wrapper class for a `std::function<void(const std::variant<nitro::NullType, std::string>& / * result * /)>`, this can be used from Swift.
   */
  class Func_void_std__variant_nitro__NullType__std__string__Wrapper final {
  public:
    explicit Func_void_std__variant_nitro__NullType__std__string__Wrapper(std::function<void(const std::variant<nitro::NullType, std::string>& /* result */)>&& func): _function(std::make_unique<std::function<void(const std::variant<nitro::NullType, std::string>& /* result */)>>(std::move(func))) {}
    inline void call(std::variant<nitro::NullType, std::string> result) const noexcept {
      _function->operator()(result);
    }
  private:
    std::unique_ptr<std::function<void(const std::variant<nitro::NullType, std::string>& /* result */)>> _function;
  } SWIFT_NONCOPYABLE;
  Func_void_std__variant_nitro__NullType__std__string_ create_Func_void_std__variant_nitro__NullType__std__string_(void* NON_NULL swiftClosureWrapper) noexcept;
  inline Func_void_std__variant_nitro__NullType__std__string__Wrapper wrap_Func_void_std__variant_nitro__NullType__std__string_(Func_void_std__variant_nitro__NullType__std__string_ value) noexcept {
    return Func_void_std__variant_nitro__NullType__std__string__Wrapper(std::move(value));
  }
  
  // pragma MARK: std::variant<nitro::NullType, NitroProduct>
  /**
   * Wrapper struct for `std::variant<nitro::NullType, NitroProduct>`.
   * std::variant cannot be used in Swift because of a Swift bug.
   * Not even specializing it works. So we create a wrapper struct.
   */
  struct std__variant_nitro__NullType__NitroProduct_ final {
    std::variant<nitro::NullType, NitroProduct> variant;
    std__variant_nitro__NullType__NitroProduct_(std::variant<nitro::NullType, NitroProduct> variant): variant(variant) { }
    operator std::variant<nitro::NullType, NitroProduct>() const noexcept {
      return variant;
    }
    inline size_t index() const noexcept {
      return variant.index();
    }
    inline nitro::NullType get_0() const noexcept {
      return std::get<0>(variant);
    }
    inline NitroProduct get_1() const noexcept {
      return std::get<1>(variant);
    }
  };
  inline std__variant_nitro__NullType__NitroProduct_ create_std__variant_nitro__NullType__NitroProduct_(nitro::NullType value) noexcept {
    return std__variant_nitro__NullType__NitroProduct_(value);
  }
  inline std__variant_nitro__NullType__NitroProduct_ create_std__variant_nitro__NullType__NitroProduct_(const NitroProduct& value) noexcept {
    return std__variant_nitro__NullType__NitroProduct_(value);
  }
  
  // pragma MARK: std::shared_ptr<Promise<std::variant<nitro::NullType, NitroProduct>>>
  /**
   * Specialized version of `std::shared_ptr<Promise<std::variant<nitro::NullType, NitroProduct>>>`.
   */
  using std__shared_ptr_Promise_std__variant_nitro__NullType__NitroProduct___ = std::shared_ptr<Promise<std::variant<nitro::NullType, NitroProduct>>>;
  inline std::shared_ptr<Promise<std::variant<nitro::NullType, NitroProduct>>> create_std__shared_ptr_Promise_std__variant_nitro__NullType__NitroProduct___() noexcept {
    return Promise<std::variant<nitro::NullType, NitroProduct>>::create();
  }
  inline PromiseHolder<std::variant<nitro::NullType, NitroProduct>> wrap_std__shared_ptr_Promise_std__variant_nitro__NullType__NitroProduct___(std::shared_ptr<Promise<std::variant<nitro::NullType, NitroProduct>>> promise) noexcept {
    return PromiseHolder<std::variant<nitro::NullType, NitroProduct>>(std::move(promise));
  }
  
  // pragma MARK: std::function<void(const std::variant<nitro::NullType, NitroProduct>& /* result */)>
  /**
   * Specialized version of `std::function<void(const std::variant<nitro::NullType, NitroProduct>&)>`.
   */
  using Func_void_std__variant_nitro__NullType__NitroProduct_ = std::function<void(const std::variant<nitro::NullType, NitroProduct>& /* result */)>;
  /**
   * Wrapper class for a `std::function<void(const std::variant<nitro::NullType, NitroProduct>& / * result * /)>`, this can be used from Swift.
   */
  class Func_void_std__variant_nitro__NullType__NitroProduct__Wrapper final {
  public:
    explicit Func_void_std__variant_nitro__NullType__NitroProduct__Wrapper(std::function<void(const std::variant<nitro::NullType, NitroProduct>& /* result */)>&& func): _function(std::make_unique<std::function<void(const std::variant<nitro::NullType, NitroProduct>& /* result */)>>(std::move(func))) {}
    inline void call(std::variant<nitro::NullType, NitroProduct> result) const noexcept {
      _function->operator()(result);
    }
  private:
    std::unique_ptr<std::function<void(const std::variant<nitro::NullType, NitroProduct>& /* result */)>> _function;
  } SWIFT_NONCOPYABLE;
  Func_void_std__variant_nitro__NullType__NitroProduct_ create_Func_void_std__variant_nitro__NullType__NitroProduct_(void* NON_NULL swiftClosureWrapper) noexcept;
  inline Func_void_std__variant_nitro__NullType__NitroProduct__Wrapper wrap_Func_void_std__variant_nitro__NullType__NitroProduct_(Func_void_std__variant_nitro__NullType__NitroProduct_ value) noexcept {
    return Func_void_std__variant_nitro__NullType__NitroProduct__Wrapper(std::move(value));
  }
  
  // pragma MARK: std::shared_ptr<Promise<void>>
  /**
   * Specialized version of `std::shared_ptr<Promise<void>>`.
   */
  using std__shared_ptr_Promise_void__ = std::shared_ptr<Promise<void>>;
  inline std::shared_ptr<Promise<void>> create_std__shared_ptr_Promise_void__() noexcept {
    return Promise<void>::create();
  }
  inline PromiseHolder<void> wrap_std__shared_ptr_Promise_void__(std::shared_ptr<Promise<void>> promise) noexcept {
    return PromiseHolder<void>(std::move(promise));
  }
  
  // pragma MARK: std::function<void()>
  /**
   * Specialized version of `std::function<void()>`.
   */
  using Func_void = std::function<void()>;
  /**
   * Wrapper class for a `std::function<void()>`, this can be used from Swift.
   */
  class Func_void_Wrapper final {
  public:
    explicit Func_void_Wrapper(std::function<void()>&& func): _function(std::make_unique<std::function<void()>>(std::move(func))) {}
    inline void call() const noexcept {
      _function->operator()();
    }
  private:
    std::unique_ptr<std::function<void()>> _function;
  } SWIFT_NONCOPYABLE;
  Func_void create_Func_void(void* NON_NULL swiftClosureWrapper) noexcept;
  inline Func_void_Wrapper wrap_Func_void(Func_void value) noexcept {
    return Func_void_Wrapper(std::move(value));
  }
  
  // pragma MARK: std::variant<nitro::NullType, NitroSubscriptionRenewalInfo>
  /**
   * Wrapper struct for `std::variant<nitro::NullType, NitroSubscriptionRenewalInfo>`.
   * std::variant cannot be used in Swift because of a Swift bug.
   * Not even specializing it works. So we create a wrapper struct.
   */
  struct std__variant_nitro__NullType__NitroSubscriptionRenewalInfo_ final {
    std::variant<nitro::NullType, NitroSubscriptionRenewalInfo> variant;
    std__variant_nitro__NullType__NitroSubscriptionRenewalInfo_(std::variant<nitro::NullType, NitroSubscriptionRenewalInfo> variant): variant(variant) { }
    operator std::variant<nitro::NullType, NitroSubscriptionRenewalInfo>() const noexcept {
      return variant;
    }
    inline size_t index() const noexcept {
      return variant.index();
    }
    inline nitro::NullType get_0() const noexcept {
      return std::get<0>(variant);
    }
    inline NitroSubscriptionRenewalInfo get_1() const noexcept {
      return std::get<1>(variant);
    }
  };
  inline std__variant_nitro__NullType__NitroSubscriptionRenewalInfo_ create_std__variant_nitro__NullType__NitroSubscriptionRenewalInfo_(nitro::NullType value) noexcept {
    return std__variant_nitro__NullType__NitroSubscriptionRenewalInfo_(value);
  }
  inline std__variant_nitro__NullType__NitroSubscriptionRenewalInfo_ create_std__variant_nitro__NullType__NitroSubscriptionRenewalInfo_(const NitroSubscriptionRenewalInfo& value) noexcept {
    return std__variant_nitro__NullType__NitroSubscriptionRenewalInfo_(value);
  }
  
  // pragma MARK: std::optional<std::variant<nitro::NullType, NitroSubscriptionRenewalInfo>>
  /**
   * Specialized version of `std::optional<std::variant<nitro::NullType, NitroSubscriptionRenewalInfo>>`.
   */
  using std__optional_std__variant_nitro__NullType__NitroSubscriptionRenewalInfo__ = std::optional<std::variant<nitro::NullType, NitroSubscriptionRenewalInfo>>;
  inline std::optional<std::variant<nitro::NullType, NitroSubscriptionRenewalInfo>> create_std__optional_std__variant_nitro__NullType__NitroSubscriptionRenewalInfo__(const std::variant<nitro::NullType, NitroSubscriptionRenewalInfo>& value) noexcept {
    return std::optional<std::variant<nitro::NullType, NitroSubscriptionRenewalInfo>>(value);
  }
  inline bool has_value_std__optional_std__variant_nitro__NullType__NitroSubscriptionRenewalInfo__(const std::optional<std::variant<nitro::NullType, NitroSubscriptionRenewalInfo>>& optional) noexcept {
    return optional.has_value();
  }
  inline std::variant<nitro::NullType, NitroSubscriptionRenewalInfo> get_std__optional_std__variant_nitro__NullType__NitroSubscriptionRenewalInfo__(const std::optional<std::variant<nitro::NullType, NitroSubscriptionRenewalInfo>>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::vector<NitroSubscriptionStatus>
  /**
   * Specialized version of `std::vector<NitroSubscriptionStatus>`.
   */
  using std__vector_NitroSubscriptionStatus_ = std::vector<NitroSubscriptionStatus>;
  inline std::vector<NitroSubscriptionStatus> create_std__vector_NitroSubscriptionStatus_(size_t size) noexcept {
    std::vector<NitroSubscriptionStatus> vector;
    vector.reserve(size);
    return vector;
  }
  
  // pragma MARK: std::variant<nitro::NullType, std::vector<NitroSubscriptionStatus>>
  /**
   * Wrapper struct for `std::variant<nitro::NullType, std::vector<NitroSubscriptionStatus>>`.
   * std::variant cannot be used in Swift because of a Swift bug.
   * Not even specializing it works. So we create a wrapper struct.
   */
  struct std__variant_nitro__NullType__std__vector_NitroSubscriptionStatus__ final {
    std::variant<nitro::NullType, std::vector<NitroSubscriptionStatus>> variant;
    std__variant_nitro__NullType__std__vector_NitroSubscriptionStatus__(std::variant<nitro::NullType, std::vector<NitroSubscriptionStatus>> variant): variant(variant) { }
    operator std::variant<nitro::NullType, std::vector<NitroSubscriptionStatus>>() const noexcept {
      return variant;
    }
    inline size_t index() const noexcept {
      return variant.index();
    }
    inline nitro::NullType get_0() const noexcept {
      return std::get<0>(variant);
    }
    inline std::vector<NitroSubscriptionStatus> get_1() const noexcept {
      return std::get<1>(variant);
    }
  };
  inline std__variant_nitro__NullType__std__vector_NitroSubscriptionStatus__ create_std__variant_nitro__NullType__std__vector_NitroSubscriptionStatus__(nitro::NullType value) noexcept {
    return std__variant_nitro__NullType__std__vector_NitroSubscriptionStatus__(value);
  }
  inline std__variant_nitro__NullType__std__vector_NitroSubscriptionStatus__ create_std__variant_nitro__NullType__std__vector_NitroSubscriptionStatus__(const std::vector<NitroSubscriptionStatus>& value) noexcept {
    return std__variant_nitro__NullType__std__vector_NitroSubscriptionStatus__(value);
  }
  
  // pragma MARK: std::shared_ptr<Promise<std::variant<nitro::NullType, std::vector<NitroSubscriptionStatus>>>>
  /**
   * Specialized version of `std::shared_ptr<Promise<std::variant<nitro::NullType, std::vector<NitroSubscriptionStatus>>>>`.
   */
  using std__shared_ptr_Promise_std__variant_nitro__NullType__std__vector_NitroSubscriptionStatus____ = std::shared_ptr<Promise<std::variant<nitro::NullType, std::vector<NitroSubscriptionStatus>>>>;
  inline std::shared_ptr<Promise<std::variant<nitro::NullType, std::vector<NitroSubscriptionStatus>>>> create_std__shared_ptr_Promise_std__variant_nitro__NullType__std__vector_NitroSubscriptionStatus____() noexcept {
    return Promise<std::variant<nitro::NullType, std::vector<NitroSubscriptionStatus>>>::create();
  }
  inline PromiseHolder<std::variant<nitro::NullType, std::vector<NitroSubscriptionStatus>>> wrap_std__shared_ptr_Promise_std__variant_nitro__NullType__std__vector_NitroSubscriptionStatus____(std::shared_ptr<Promise<std::variant<nitro::NullType, std::vector<NitroSubscriptionStatus>>>> promise) noexcept {
    return PromiseHolder<std::variant<nitro::NullType, std::vector<NitroSubscriptionStatus>>>(std::move(promise));
  }
  
  // pragma MARK: std::function<void(const std::variant<nitro::NullType, std::vector<NitroSubscriptionStatus>>& /* result */)>
  /**
   * Specialized version of `std::function<void(const std::variant<nitro::NullType, std::vector<NitroSubscriptionStatus>>&)>`.
   */
  using Func_void_std__variant_nitro__NullType__std__vector_NitroSubscriptionStatus__ = std::function<void(const std::variant<nitro::NullType, std::vector<NitroSubscriptionStatus>>& /* result */)>;
  /**
   * Wrapper class for a `std::function<void(const std::variant<nitro::NullType, std::vector<NitroSubscriptionStatus>>& / * result * /)>`, this can be used from Swift.
   */
  class Func_void_std__variant_nitro__NullType__std__vector_NitroSubscriptionStatus___Wrapper final {
  public:
    explicit Func_void_std__variant_nitro__NullType__std__vector_NitroSubscriptionStatus___Wrapper(std::function<void(const std::variant<nitro::NullType, std::vector<NitroSubscriptionStatus>>& /* result */)>&& func): _function(std::make_unique<std::function<void(const std::variant<nitro::NullType, std::vector<NitroSubscriptionStatus>>& /* result */)>>(std::move(func))) {}
    inline void call(std::variant<nitro::NullType, std::vector<NitroSubscriptionStatus>> result) const noexcept {
      _function->operator()(result);
    }
  private:
    std::unique_ptr<std::function<void(const std::variant<nitro::NullType, std::vector<NitroSubscriptionStatus>>& /* result */)>> _function;
  } SWIFT_NONCOPYABLE;
  Func_void_std__variant_nitro__NullType__std__vector_NitroSubscriptionStatus__ create_Func_void_std__variant_nitro__NullType__std__vector_NitroSubscriptionStatus__(void* NON_NULL swiftClosureWrapper) noexcept;
  inline Func_void_std__variant_nitro__NullType__std__vector_NitroSubscriptionStatus___Wrapper wrap_Func_void_std__variant_nitro__NullType__std__vector_NitroSubscriptionStatus__(Func_void_std__variant_nitro__NullType__std__vector_NitroSubscriptionStatus__ value) noexcept {
    return Func_void_std__variant_nitro__NullType__std__vector_NitroSubscriptionStatus___Wrapper(std::move(value));
  }
  
  // pragma MARK: std::variant<nitro::NullType, NitroPurchase>
  /**
   * Wrapper struct for `std::variant<nitro::NullType, NitroPurchase>`.
   * std::variant cannot be used in Swift because of a Swift bug.
   * Not even specializing it works. So we create a wrapper struct.
   */
  struct std__variant_nitro__NullType__NitroPurchase_ final {
    std::variant<nitro::NullType, NitroPurchase> variant;
    std__variant_nitro__NullType__NitroPurchase_(std::variant<nitro::NullType, NitroPurchase> variant): variant(variant) { }
    operator std::variant<nitro::NullType, NitroPurchase>() const noexcept {
      return variant;
    }
    inline size_t index() const noexcept {
      return variant.index();
    }
    inline nitro::NullType get_0() const noexcept {
      return std::get<0>(variant);
    }
    inline NitroPurchase get_1() const noexcept {
      return std::get<1>(variant);
    }
  };
  inline std__variant_nitro__NullType__NitroPurchase_ create_std__variant_nitro__NullType__NitroPurchase_(nitro::NullType value) noexcept {
    return std__variant_nitro__NullType__NitroPurchase_(value);
  }
  inline std__variant_nitro__NullType__NitroPurchase_ create_std__variant_nitro__NullType__NitroPurchase_(const NitroPurchase& value) noexcept {
    return std__variant_nitro__NullType__NitroPurchase_(value);
  }
  
  // pragma MARK: std::shared_ptr<Promise<std::variant<nitro::NullType, NitroPurchase>>>
  /**
   * Specialized version of `std::shared_ptr<Promise<std::variant<nitro::NullType, NitroPurchase>>>`.
   */
  using std__shared_ptr_Promise_std__variant_nitro__NullType__NitroPurchase___ = std::shared_ptr<Promise<std::variant<nitro::NullType, NitroPurchase>>>;
  inline std::shared_ptr<Promise<std::variant<nitro::NullType, NitroPurchase>>> create_std__shared_ptr_Promise_std__variant_nitro__NullType__NitroPurchase___() noexcept {
    return Promise<std::variant<nitro::NullType, NitroPurchase>>::create();
  }
  inline PromiseHolder<std::variant<nitro::NullType, NitroPurchase>> wrap_std__shared_ptr_Promise_std__variant_nitro__NullType__NitroPurchase___(std::shared_ptr<Promise<std::variant<nitro::NullType, NitroPurchase>>> promise) noexcept {
    return PromiseHolder<std::variant<nitro::NullType, NitroPurchase>>(std::move(promise));
  }
  
  // pragma MARK: std::function<void(const std::variant<nitro::NullType, NitroPurchase>& /* result */)>
  /**
   * Specialized version of `std::function<void(const std::variant<nitro::NullType, NitroPurchase>&)>`.
   */
  using Func_void_std__variant_nitro__NullType__NitroPurchase_ = std::function<void(const std::variant<nitro::NullType, NitroPurchase>& /* result */)>;
  /**
   * Wrapper class for a `std::function<void(const std::variant<nitro::NullType, NitroPurchase>& / * result * /)>`, this can be used from Swift.
   */
  class Func_void_std__variant_nitro__NullType__NitroPurchase__Wrapper final {
  public:
    explicit Func_void_std__variant_nitro__NullType__NitroPurchase__Wrapper(std::function<void(const std::variant<nitro::NullType, NitroPurchase>& /* result */)>&& func): _function(std::make_unique<std::function<void(const std::variant<nitro::NullType, NitroPurchase>& /* result */)>>(std::move(func))) {}
    inline void call(std::variant<nitro::NullType, NitroPurchase> result) const noexcept {
      _function->operator()(result);
    }
  private:
    std::unique_ptr<std::function<void(const std::variant<nitro::NullType, NitroPurchase>& /* result */)>> _function;
  } SWIFT_NONCOPYABLE;
  Func_void_std__variant_nitro__NullType__NitroPurchase_ create_Func_void_std__variant_nitro__NullType__NitroPurchase_(void* NON_NULL swiftClosureWrapper) noexcept;
  inline Func_void_std__variant_nitro__NullType__NitroPurchase__Wrapper wrap_Func_void_std__variant_nitro__NullType__NitroPurchase_(Func_void_std__variant_nitro__NullType__NitroPurchase_ value) noexcept {
    return Func_void_std__variant_nitro__NullType__NitroPurchase__Wrapper(std::move(value));
  }
  
  // pragma MARK: std::optional<std::variant<nitro::NullType, NitroPurchase>>
  /**
   * Specialized version of `std::optional<std::variant<nitro::NullType, NitroPurchase>>`.
   */
  using std__optional_std__variant_nitro__NullType__NitroPurchase__ = std::optional<std::variant<nitro::NullType, NitroPurchase>>;
  inline std::optional<std::variant<nitro::NullType, NitroPurchase>> create_std__optional_std__variant_nitro__NullType__NitroPurchase__(const std::variant<nitro::NullType, NitroPurchase>& value) noexcept {
    return std::optional<std::variant<nitro::NullType, NitroPurchase>>(value);
  }
  inline bool has_value_std__optional_std__variant_nitro__NullType__NitroPurchase__(const std::optional<std::variant<nitro::NullType, NitroPurchase>>& optional) noexcept {
    return optional.has_value();
  }
  inline std::variant<nitro::NullType, NitroPurchase> get_std__optional_std__variant_nitro__NullType__NitroPurchase__(const std::optional<std::variant<nitro::NullType, NitroPurchase>>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::variant<NitroReceiptValidationResultIOS, NitroReceiptValidationResultAndroid>
  /**
   * Wrapper struct for `std::variant<NitroReceiptValidationResultIOS, NitroReceiptValidationResultAndroid>`.
   * std::variant cannot be used in Swift because of a Swift bug.
   * Not even specializing it works. So we create a wrapper struct.
   */
  struct std__variant_NitroReceiptValidationResultIOS__NitroReceiptValidationResultAndroid_ final {
    std::variant<NitroReceiptValidationResultIOS, NitroReceiptValidationResultAndroid> variant;
    std__variant_NitroReceiptValidationResultIOS__NitroReceiptValidationResultAndroid_(std::variant<NitroReceiptValidationResultIOS, NitroReceiptValidationResultAndroid> variant): variant(variant) { }
    operator std::variant<NitroReceiptValidationResultIOS, NitroReceiptValidationResultAndroid>() const noexcept {
      return variant;
    }
    inline size_t index() const noexcept {
      return variant.index();
    }
    inline NitroReceiptValidationResultIOS get_0() const noexcept {
      return std::get<0>(variant);
    }
    inline NitroReceiptValidationResultAndroid get_1() const noexcept {
      return std::get<1>(variant);
    }
  };
  inline std__variant_NitroReceiptValidationResultIOS__NitroReceiptValidationResultAndroid_ create_std__variant_NitroReceiptValidationResultIOS__NitroReceiptValidationResultAndroid_(const NitroReceiptValidationResultIOS& value) noexcept {
    return std__variant_NitroReceiptValidationResultIOS__NitroReceiptValidationResultAndroid_(value);
  }
  inline std__variant_NitroReceiptValidationResultIOS__NitroReceiptValidationResultAndroid_ create_std__variant_NitroReceiptValidationResultIOS__NitroReceiptValidationResultAndroid_(const NitroReceiptValidationResultAndroid& value) noexcept {
    return std__variant_NitroReceiptValidationResultIOS__NitroReceiptValidationResultAndroid_(value);
  }
  
  // pragma MARK: std::shared_ptr<Promise<std::variant<NitroReceiptValidationResultIOS, NitroReceiptValidationResultAndroid>>>
  /**
   * Specialized version of `std::shared_ptr<Promise<std::variant<NitroReceiptValidationResultIOS, NitroReceiptValidationResultAndroid>>>`.
   */
  using std__shared_ptr_Promise_std__variant_NitroReceiptValidationResultIOS__NitroReceiptValidationResultAndroid___ = std::shared_ptr<Promise<std::variant<NitroReceiptValidationResultIOS, NitroReceiptValidationResultAndroid>>>;
  inline std::shared_ptr<Promise<std::variant<NitroReceiptValidationResultIOS, NitroReceiptValidationResultAndroid>>> create_std__shared_ptr_Promise_std__variant_NitroReceiptValidationResultIOS__NitroReceiptValidationResultAndroid___() noexcept {
    return Promise<std::variant<NitroReceiptValidationResultIOS, NitroReceiptValidationResultAndroid>>::create();
  }
  inline PromiseHolder<std::variant<NitroReceiptValidationResultIOS, NitroReceiptValidationResultAndroid>> wrap_std__shared_ptr_Promise_std__variant_NitroReceiptValidationResultIOS__NitroReceiptValidationResultAndroid___(std::shared_ptr<Promise<std::variant<NitroReceiptValidationResultIOS, NitroReceiptValidationResultAndroid>>> promise) noexcept {
    return PromiseHolder<std::variant<NitroReceiptValidationResultIOS, NitroReceiptValidationResultAndroid>>(std::move(promise));
  }
  
  // pragma MARK: std::function<void(const std::variant<NitroReceiptValidationResultIOS, NitroReceiptValidationResultAndroid>& /* result */)>
  /**
   * Specialized version of `std::function<void(const std::variant<NitroReceiptValidationResultIOS, NitroReceiptValidationResultAndroid>&)>`.
   */
  using Func_void_std__variant_NitroReceiptValidationResultIOS__NitroReceiptValidationResultAndroid_ = std::function<void(const std::variant<NitroReceiptValidationResultIOS, NitroReceiptValidationResultAndroid>& /* result */)>;
  /**
   * Wrapper class for a `std::function<void(const std::variant<NitroReceiptValidationResultIOS, NitroReceiptValidationResultAndroid>& / * result * /)>`, this can be used from Swift.
   */
  class Func_void_std__variant_NitroReceiptValidationResultIOS__NitroReceiptValidationResultAndroid__Wrapper final {
  public:
    explicit Func_void_std__variant_NitroReceiptValidationResultIOS__NitroReceiptValidationResultAndroid__Wrapper(std::function<void(const std::variant<NitroReceiptValidationResultIOS, NitroReceiptValidationResultAndroid>& /* result */)>&& func): _function(std::make_unique<std::function<void(const std::variant<NitroReceiptValidationResultIOS, NitroReceiptValidationResultAndroid>& /* result */)>>(std::move(func))) {}
    inline void call(std::variant<NitroReceiptValidationResultIOS, NitroReceiptValidationResultAndroid> result) const noexcept {
      _function->operator()(result);
    }
  private:
    std::unique_ptr<std::function<void(const std::variant<NitroReceiptValidationResultIOS, NitroReceiptValidationResultAndroid>& /* result */)>> _function;
  } SWIFT_NONCOPYABLE;
  Func_void_std__variant_NitroReceiptValidationResultIOS__NitroReceiptValidationResultAndroid_ create_Func_void_std__variant_NitroReceiptValidationResultIOS__NitroReceiptValidationResultAndroid_(void* NON_NULL swiftClosureWrapper) noexcept;
  inline Func_void_std__variant_NitroReceiptValidationResultIOS__NitroReceiptValidationResultAndroid__Wrapper wrap_Func_void_std__variant_NitroReceiptValidationResultIOS__NitroReceiptValidationResultAndroid_(Func_void_std__variant_NitroReceiptValidationResultIOS__NitroReceiptValidationResultAndroid_ value) noexcept {
    return Func_void_std__variant_NitroReceiptValidationResultIOS__NitroReceiptValidationResultAndroid__Wrapper(std::move(value));
  }
  
  // pragma MARK: std::variant<nitro::NullType, NitroReceiptValidationAppleOptions>
  /**
   * Wrapper struct for `std::variant<nitro::NullType, NitroReceiptValidationAppleOptions>`.
   * std::variant cannot be used in Swift because of a Swift bug.
   * Not even specializing it works. So we create a wrapper struct.
   */
  struct std__variant_nitro__NullType__NitroReceiptValidationAppleOptions_ final {
    std::variant<nitro::NullType, NitroReceiptValidationAppleOptions> variant;
    std__variant_nitro__NullType__NitroReceiptValidationAppleOptions_(std::variant<nitro::NullType, NitroReceiptValidationAppleOptions> variant): variant(variant) { }
    operator std::variant<nitro::NullType, NitroReceiptValidationAppleOptions>() const noexcept {
      return variant;
    }
    inline size_t index() const noexcept {
      return variant.index();
    }
    inline nitro::NullType get_0() const noexcept {
      return std::get<0>(variant);
    }
    inline NitroReceiptValidationAppleOptions get_1() const noexcept {
      return std::get<1>(variant);
    }
  };
  inline std__variant_nitro__NullType__NitroReceiptValidationAppleOptions_ create_std__variant_nitro__NullType__NitroReceiptValidationAppleOptions_(nitro::NullType value) noexcept {
    return std__variant_nitro__NullType__NitroReceiptValidationAppleOptions_(value);
  }
  inline std__variant_nitro__NullType__NitroReceiptValidationAppleOptions_ create_std__variant_nitro__NullType__NitroReceiptValidationAppleOptions_(const NitroReceiptValidationAppleOptions& value) noexcept {
    return std__variant_nitro__NullType__NitroReceiptValidationAppleOptions_(value);
  }
  
  // pragma MARK: std::optional<std::variant<nitro::NullType, NitroReceiptValidationAppleOptions>>
  /**
   * Specialized version of `std::optional<std::variant<nitro::NullType, NitroReceiptValidationAppleOptions>>`.
   */
  using std__optional_std__variant_nitro__NullType__NitroReceiptValidationAppleOptions__ = std::optional<std::variant<nitro::NullType, NitroReceiptValidationAppleOptions>>;
  inline std::optional<std::variant<nitro::NullType, NitroReceiptValidationAppleOptions>> create_std__optional_std__variant_nitro__NullType__NitroReceiptValidationAppleOptions__(const std::variant<nitro::NullType, NitroReceiptValidationAppleOptions>& value) noexcept {
    return std::optional<std::variant<nitro::NullType, NitroReceiptValidationAppleOptions>>(value);
  }
  inline bool has_value_std__optional_std__variant_nitro__NullType__NitroReceiptValidationAppleOptions__(const std::optional<std::variant<nitro::NullType, NitroReceiptValidationAppleOptions>>& optional) noexcept {
    return optional.has_value();
  }
  inline std::variant<nitro::NullType, NitroReceiptValidationAppleOptions> get_std__optional_std__variant_nitro__NullType__NitroReceiptValidationAppleOptions__(const std::optional<std::variant<nitro::NullType, NitroReceiptValidationAppleOptions>>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::variant<nitro::NullType, NitroReceiptValidationGoogleOptions>
  /**
   * Wrapper struct for `std::variant<nitro::NullType, NitroReceiptValidationGoogleOptions>`.
   * std::variant cannot be used in Swift because of a Swift bug.
   * Not even specializing it works. So we create a wrapper struct.
   */
  struct std__variant_nitro__NullType__NitroReceiptValidationGoogleOptions_ final {
    std::variant<nitro::NullType, NitroReceiptValidationGoogleOptions> variant;
    std__variant_nitro__NullType__NitroReceiptValidationGoogleOptions_(std::variant<nitro::NullType, NitroReceiptValidationGoogleOptions> variant): variant(variant) { }
    operator std::variant<nitro::NullType, NitroReceiptValidationGoogleOptions>() const noexcept {
      return variant;
    }
    inline size_t index() const noexcept {
      return variant.index();
    }
    inline nitro::NullType get_0() const noexcept {
      return std::get<0>(variant);
    }
    inline NitroReceiptValidationGoogleOptions get_1() const noexcept {
      return std::get<1>(variant);
    }
  };
  inline std__variant_nitro__NullType__NitroReceiptValidationGoogleOptions_ create_std__variant_nitro__NullType__NitroReceiptValidationGoogleOptions_(nitro::NullType value) noexcept {
    return std__variant_nitro__NullType__NitroReceiptValidationGoogleOptions_(value);
  }
  inline std__variant_nitro__NullType__NitroReceiptValidationGoogleOptions_ create_std__variant_nitro__NullType__NitroReceiptValidationGoogleOptions_(const NitroReceiptValidationGoogleOptions& value) noexcept {
    return std__variant_nitro__NullType__NitroReceiptValidationGoogleOptions_(value);
  }
  
  // pragma MARK: std::optional<std::variant<nitro::NullType, NitroReceiptValidationGoogleOptions>>
  /**
   * Specialized version of `std::optional<std::variant<nitro::NullType, NitroReceiptValidationGoogleOptions>>`.
   */
  using std__optional_std__variant_nitro__NullType__NitroReceiptValidationGoogleOptions__ = std::optional<std::variant<nitro::NullType, NitroReceiptValidationGoogleOptions>>;
  inline std::optional<std::variant<nitro::NullType, NitroReceiptValidationGoogleOptions>> create_std__optional_std__variant_nitro__NullType__NitroReceiptValidationGoogleOptions__(const std::variant<nitro::NullType, NitroReceiptValidationGoogleOptions>& value) noexcept {
    return std::optional<std::variant<nitro::NullType, NitroReceiptValidationGoogleOptions>>(value);
  }
  inline bool has_value_std__optional_std__variant_nitro__NullType__NitroReceiptValidationGoogleOptions__(const std::optional<std::variant<nitro::NullType, NitroReceiptValidationGoogleOptions>>& optional) noexcept {
    return optional.has_value();
  }
  inline std::variant<nitro::NullType, NitroReceiptValidationGoogleOptions> get_std__optional_std__variant_nitro__NullType__NitroReceiptValidationGoogleOptions__(const std::optional<std::variant<nitro::NullType, NitroReceiptValidationGoogleOptions>>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::variant<nitro::NullType, NitroReceiptValidationHorizonOptions>
  /**
   * Wrapper struct for `std::variant<nitro::NullType, NitroReceiptValidationHorizonOptions>`.
   * std::variant cannot be used in Swift because of a Swift bug.
   * Not even specializing it works. So we create a wrapper struct.
   */
  struct std__variant_nitro__NullType__NitroReceiptValidationHorizonOptions_ final {
    std::variant<nitro::NullType, NitroReceiptValidationHorizonOptions> variant;
    std__variant_nitro__NullType__NitroReceiptValidationHorizonOptions_(std::variant<nitro::NullType, NitroReceiptValidationHorizonOptions> variant): variant(variant) { }
    operator std::variant<nitro::NullType, NitroReceiptValidationHorizonOptions>() const noexcept {
      return variant;
    }
    inline size_t index() const noexcept {
      return variant.index();
    }
    inline nitro::NullType get_0() const noexcept {
      return std::get<0>(variant);
    }
    inline NitroReceiptValidationHorizonOptions get_1() const noexcept {
      return std::get<1>(variant);
    }
  };
  inline std__variant_nitro__NullType__NitroReceiptValidationHorizonOptions_ create_std__variant_nitro__NullType__NitroReceiptValidationHorizonOptions_(nitro::NullType value) noexcept {
    return std__variant_nitro__NullType__NitroReceiptValidationHorizonOptions_(value);
  }
  inline std__variant_nitro__NullType__NitroReceiptValidationHorizonOptions_ create_std__variant_nitro__NullType__NitroReceiptValidationHorizonOptions_(const NitroReceiptValidationHorizonOptions& value) noexcept {
    return std__variant_nitro__NullType__NitroReceiptValidationHorizonOptions_(value);
  }
  
  // pragma MARK: std::optional<std::variant<nitro::NullType, NitroReceiptValidationHorizonOptions>>
  /**
   * Specialized version of `std::optional<std::variant<nitro::NullType, NitroReceiptValidationHorizonOptions>>`.
   */
  using std__optional_std__variant_nitro__NullType__NitroReceiptValidationHorizonOptions__ = std::optional<std::variant<nitro::NullType, NitroReceiptValidationHorizonOptions>>;
  inline std::optional<std::variant<nitro::NullType, NitroReceiptValidationHorizonOptions>> create_std__optional_std__variant_nitro__NullType__NitroReceiptValidationHorizonOptions__(const std::variant<nitro::NullType, NitroReceiptValidationHorizonOptions>& value) noexcept {
    return std::optional<std::variant<nitro::NullType, NitroReceiptValidationHorizonOptions>>(value);
  }
  inline bool has_value_std__optional_std__variant_nitro__NullType__NitroReceiptValidationHorizonOptions__(const std::optional<std::variant<nitro::NullType, NitroReceiptValidationHorizonOptions>>& optional) noexcept {
    return optional.has_value();
  }
  inline std::variant<nitro::NullType, NitroReceiptValidationHorizonOptions> get_std__optional_std__variant_nitro__NullType__NitroReceiptValidationHorizonOptions__(const std::optional<std::variant<nitro::NullType, NitroReceiptValidationHorizonOptions>>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::variant<nitro::NullType, NitroVerifyPurchaseWithIapkitResult>
  /**
   * Wrapper struct for `std::variant<nitro::NullType, NitroVerifyPurchaseWithIapkitResult>`.
   * std::variant cannot be used in Swift because of a Swift bug.
   * Not even specializing it works. So we create a wrapper struct.
   */
  struct std__variant_nitro__NullType__NitroVerifyPurchaseWithIapkitResult_ final {
    std::variant<nitro::NullType, NitroVerifyPurchaseWithIapkitResult> variant;
    std__variant_nitro__NullType__NitroVerifyPurchaseWithIapkitResult_(std::variant<nitro::NullType, NitroVerifyPurchaseWithIapkitResult> variant): variant(variant) { }
    operator std::variant<nitro::NullType, NitroVerifyPurchaseWithIapkitResult>() const noexcept {
      return variant;
    }
    inline size_t index() const noexcept {
      return variant.index();
    }
    inline nitro::NullType get_0() const noexcept {
      return std::get<0>(variant);
    }
    inline NitroVerifyPurchaseWithIapkitResult get_1() const noexcept {
      return std::get<1>(variant);
    }
  };
  inline std__variant_nitro__NullType__NitroVerifyPurchaseWithIapkitResult_ create_std__variant_nitro__NullType__NitroVerifyPurchaseWithIapkitResult_(nitro::NullType value) noexcept {
    return std__variant_nitro__NullType__NitroVerifyPurchaseWithIapkitResult_(value);
  }
  inline std__variant_nitro__NullType__NitroVerifyPurchaseWithIapkitResult_ create_std__variant_nitro__NullType__NitroVerifyPurchaseWithIapkitResult_(const NitroVerifyPurchaseWithIapkitResult& value) noexcept {
    return std__variant_nitro__NullType__NitroVerifyPurchaseWithIapkitResult_(value);
  }
  
  // pragma MARK: std::optional<std::variant<nitro::NullType, NitroVerifyPurchaseWithIapkitResult>>
  /**
   * Specialized version of `std::optional<std::variant<nitro::NullType, NitroVerifyPurchaseWithIapkitResult>>`.
   */
  using std__optional_std__variant_nitro__NullType__NitroVerifyPurchaseWithIapkitResult__ = std::optional<std::variant<nitro::NullType, NitroVerifyPurchaseWithIapkitResult>>;
  inline std::optional<std::variant<nitro::NullType, NitroVerifyPurchaseWithIapkitResult>> create_std__optional_std__variant_nitro__NullType__NitroVerifyPurchaseWithIapkitResult__(const std::variant<nitro::NullType, NitroVerifyPurchaseWithIapkitResult>& value) noexcept {
    return std::optional<std::variant<nitro::NullType, NitroVerifyPurchaseWithIapkitResult>>(value);
  }
  inline bool has_value_std__optional_std__variant_nitro__NullType__NitroVerifyPurchaseWithIapkitResult__(const std::optional<std::variant<nitro::NullType, NitroVerifyPurchaseWithIapkitResult>>& optional) noexcept {
    return optional.has_value();
  }
  inline std::variant<nitro::NullType, NitroVerifyPurchaseWithIapkitResult> get_std__optional_std__variant_nitro__NullType__NitroVerifyPurchaseWithIapkitResult__(const std::optional<std::variant<nitro::NullType, NitroVerifyPurchaseWithIapkitResult>>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::vector<NitroVerifyPurchaseWithProviderError>
  /**
   * Specialized version of `std::vector<NitroVerifyPurchaseWithProviderError>`.
   */
  using std__vector_NitroVerifyPurchaseWithProviderError_ = std::vector<NitroVerifyPurchaseWithProviderError>;
  inline std::vector<NitroVerifyPurchaseWithProviderError> create_std__vector_NitroVerifyPurchaseWithProviderError_(size_t size) noexcept {
    std::vector<NitroVerifyPurchaseWithProviderError> vector;
    vector.reserve(size);
    return vector;
  }
  
  // pragma MARK: std::variant<nitro::NullType, std::vector<NitroVerifyPurchaseWithProviderError>>
  /**
   * Wrapper struct for `std::variant<nitro::NullType, std::vector<NitroVerifyPurchaseWithProviderError>>`.
   * std::variant cannot be used in Swift because of a Swift bug.
   * Not even specializing it works. So we create a wrapper struct.
   */
  struct std__variant_nitro__NullType__std__vector_NitroVerifyPurchaseWithProviderError__ final {
    std::variant<nitro::NullType, std::vector<NitroVerifyPurchaseWithProviderError>> variant;
    std__variant_nitro__NullType__std__vector_NitroVerifyPurchaseWithProviderError__(std::variant<nitro::NullType, std::vector<NitroVerifyPurchaseWithProviderError>> variant): variant(variant) { }
    operator std::variant<nitro::NullType, std::vector<NitroVerifyPurchaseWithProviderError>>() const noexcept {
      return variant;
    }
    inline size_t index() const noexcept {
      return variant.index();
    }
    inline nitro::NullType get_0() const noexcept {
      return std::get<0>(variant);
    }
    inline std::vector<NitroVerifyPurchaseWithProviderError> get_1() const noexcept {
      return std::get<1>(variant);
    }
  };
  inline std__variant_nitro__NullType__std__vector_NitroVerifyPurchaseWithProviderError__ create_std__variant_nitro__NullType__std__vector_NitroVerifyPurchaseWithProviderError__(nitro::NullType value) noexcept {
    return std__variant_nitro__NullType__std__vector_NitroVerifyPurchaseWithProviderError__(value);
  }
  inline std__variant_nitro__NullType__std__vector_NitroVerifyPurchaseWithProviderError__ create_std__variant_nitro__NullType__std__vector_NitroVerifyPurchaseWithProviderError__(const std::vector<NitroVerifyPurchaseWithProviderError>& value) noexcept {
    return std__variant_nitro__NullType__std__vector_NitroVerifyPurchaseWithProviderError__(value);
  }
  
  // pragma MARK: std::optional<std::variant<nitro::NullType, std::vector<NitroVerifyPurchaseWithProviderError>>>
  /**
   * Specialized version of `std::optional<std::variant<nitro::NullType, std::vector<NitroVerifyPurchaseWithProviderError>>>`.
   */
  using std__optional_std__variant_nitro__NullType__std__vector_NitroVerifyPurchaseWithProviderError___ = std::optional<std::variant<nitro::NullType, std::vector<NitroVerifyPurchaseWithProviderError>>>;
  inline std::optional<std::variant<nitro::NullType, std::vector<NitroVerifyPurchaseWithProviderError>>> create_std__optional_std__variant_nitro__NullType__std__vector_NitroVerifyPurchaseWithProviderError___(const std::variant<nitro::NullType, std::vector<NitroVerifyPurchaseWithProviderError>>& value) noexcept {
    return std::optional<std::variant<nitro::NullType, std::vector<NitroVerifyPurchaseWithProviderError>>>(value);
  }
  inline bool has_value_std__optional_std__variant_nitro__NullType__std__vector_NitroVerifyPurchaseWithProviderError___(const std::optional<std::variant<nitro::NullType, std::vector<NitroVerifyPurchaseWithProviderError>>>& optional) noexcept {
    return optional.has_value();
  }
  inline std::variant<nitro::NullType, std::vector<NitroVerifyPurchaseWithProviderError>> get_std__optional_std__variant_nitro__NullType__std__vector_NitroVerifyPurchaseWithProviderError___(const std::optional<std::variant<nitro::NullType, std::vector<NitroVerifyPurchaseWithProviderError>>>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::shared_ptr<Promise<NitroVerifyPurchaseWithProviderResult>>
  /**
   * Specialized version of `std::shared_ptr<Promise<NitroVerifyPurchaseWithProviderResult>>`.
   */
  using std__shared_ptr_Promise_NitroVerifyPurchaseWithProviderResult__ = std::shared_ptr<Promise<NitroVerifyPurchaseWithProviderResult>>;
  inline std::shared_ptr<Promise<NitroVerifyPurchaseWithProviderResult>> create_std__shared_ptr_Promise_NitroVerifyPurchaseWithProviderResult__() noexcept {
    return Promise<NitroVerifyPurchaseWithProviderResult>::create();
  }
  inline PromiseHolder<NitroVerifyPurchaseWithProviderResult> wrap_std__shared_ptr_Promise_NitroVerifyPurchaseWithProviderResult__(std::shared_ptr<Promise<NitroVerifyPurchaseWithProviderResult>> promise) noexcept {
    return PromiseHolder<NitroVerifyPurchaseWithProviderResult>(std::move(promise));
  }
  
  // pragma MARK: std::function<void(const NitroVerifyPurchaseWithProviderResult& /* result */)>
  /**
   * Specialized version of `std::function<void(const NitroVerifyPurchaseWithProviderResult&)>`.
   */
  using Func_void_NitroVerifyPurchaseWithProviderResult = std::function<void(const NitroVerifyPurchaseWithProviderResult& /* result */)>;
  /**
   * Wrapper class for a `std::function<void(const NitroVerifyPurchaseWithProviderResult& / * result * /)>`, this can be used from Swift.
   */
  class Func_void_NitroVerifyPurchaseWithProviderResult_Wrapper final {
  public:
    explicit Func_void_NitroVerifyPurchaseWithProviderResult_Wrapper(std::function<void(const NitroVerifyPurchaseWithProviderResult& /* result */)>&& func): _function(std::make_unique<std::function<void(const NitroVerifyPurchaseWithProviderResult& /* result */)>>(std::move(func))) {}
    inline void call(NitroVerifyPurchaseWithProviderResult result) const noexcept {
      _function->operator()(result);
    }
  private:
    std::unique_ptr<std::function<void(const NitroVerifyPurchaseWithProviderResult& /* result */)>> _function;
  } SWIFT_NONCOPYABLE;
  Func_void_NitroVerifyPurchaseWithProviderResult create_Func_void_NitroVerifyPurchaseWithProviderResult(void* NON_NULL swiftClosureWrapper) noexcept;
  inline Func_void_NitroVerifyPurchaseWithProviderResult_Wrapper wrap_Func_void_NitroVerifyPurchaseWithProviderResult(Func_void_NitroVerifyPurchaseWithProviderResult value) noexcept {
    return Func_void_NitroVerifyPurchaseWithProviderResult_Wrapper(std::move(value));
  }
  
  // pragma MARK: std::variant<nitro::NullType, NitroVerifyPurchaseWithIapkitAppleProps>
  /**
   * Wrapper struct for `std::variant<nitro::NullType, NitroVerifyPurchaseWithIapkitAppleProps>`.
   * std::variant cannot be used in Swift because of a Swift bug.
   * Not even specializing it works. So we create a wrapper struct.
   */
  struct std__variant_nitro__NullType__NitroVerifyPurchaseWithIapkitAppleProps_ final {
    std::variant<nitro::NullType, NitroVerifyPurchaseWithIapkitAppleProps> variant;
    std__variant_nitro__NullType__NitroVerifyPurchaseWithIapkitAppleProps_(std::variant<nitro::NullType, NitroVerifyPurchaseWithIapkitAppleProps> variant): variant(variant) { }
    operator std::variant<nitro::NullType, NitroVerifyPurchaseWithIapkitAppleProps>() const noexcept {
      return variant;
    }
    inline size_t index() const noexcept {
      return variant.index();
    }
    inline nitro::NullType get_0() const noexcept {
      return std::get<0>(variant);
    }
    inline NitroVerifyPurchaseWithIapkitAppleProps get_1() const noexcept {
      return std::get<1>(variant);
    }
  };
  inline std__variant_nitro__NullType__NitroVerifyPurchaseWithIapkitAppleProps_ create_std__variant_nitro__NullType__NitroVerifyPurchaseWithIapkitAppleProps_(nitro::NullType value) noexcept {
    return std__variant_nitro__NullType__NitroVerifyPurchaseWithIapkitAppleProps_(value);
  }
  inline std__variant_nitro__NullType__NitroVerifyPurchaseWithIapkitAppleProps_ create_std__variant_nitro__NullType__NitroVerifyPurchaseWithIapkitAppleProps_(const NitroVerifyPurchaseWithIapkitAppleProps& value) noexcept {
    return std__variant_nitro__NullType__NitroVerifyPurchaseWithIapkitAppleProps_(value);
  }
  
  // pragma MARK: std::optional<std::variant<nitro::NullType, NitroVerifyPurchaseWithIapkitAppleProps>>
  /**
   * Specialized version of `std::optional<std::variant<nitro::NullType, NitroVerifyPurchaseWithIapkitAppleProps>>`.
   */
  using std__optional_std__variant_nitro__NullType__NitroVerifyPurchaseWithIapkitAppleProps__ = std::optional<std::variant<nitro::NullType, NitroVerifyPurchaseWithIapkitAppleProps>>;
  inline std::optional<std::variant<nitro::NullType, NitroVerifyPurchaseWithIapkitAppleProps>> create_std__optional_std__variant_nitro__NullType__NitroVerifyPurchaseWithIapkitAppleProps__(const std::variant<nitro::NullType, NitroVerifyPurchaseWithIapkitAppleProps>& value) noexcept {
    return std::optional<std::variant<nitro::NullType, NitroVerifyPurchaseWithIapkitAppleProps>>(value);
  }
  inline bool has_value_std__optional_std__variant_nitro__NullType__NitroVerifyPurchaseWithIapkitAppleProps__(const std::optional<std::variant<nitro::NullType, NitroVerifyPurchaseWithIapkitAppleProps>>& optional) noexcept {
    return optional.has_value();
  }
  inline std::variant<nitro::NullType, NitroVerifyPurchaseWithIapkitAppleProps> get_std__optional_std__variant_nitro__NullType__NitroVerifyPurchaseWithIapkitAppleProps__(const std::optional<std::variant<nitro::NullType, NitroVerifyPurchaseWithIapkitAppleProps>>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::variant<nitro::NullType, NitroVerifyPurchaseWithIapkitGoogleProps>
  /**
   * Wrapper struct for `std::variant<nitro::NullType, NitroVerifyPurchaseWithIapkitGoogleProps>`.
   * std::variant cannot be used in Swift because of a Swift bug.
   * Not even specializing it works. So we create a wrapper struct.
   */
  struct std__variant_nitro__NullType__NitroVerifyPurchaseWithIapkitGoogleProps_ final {
    std::variant<nitro::NullType, NitroVerifyPurchaseWithIapkitGoogleProps> variant;
    std__variant_nitro__NullType__NitroVerifyPurchaseWithIapkitGoogleProps_(std::variant<nitro::NullType, NitroVerifyPurchaseWithIapkitGoogleProps> variant): variant(variant) { }
    operator std::variant<nitro::NullType, NitroVerifyPurchaseWithIapkitGoogleProps>() const noexcept {
      return variant;
    }
    inline size_t index() const noexcept {
      return variant.index();
    }
    inline nitro::NullType get_0() const noexcept {
      return std::get<0>(variant);
    }
    inline NitroVerifyPurchaseWithIapkitGoogleProps get_1() const noexcept {
      return std::get<1>(variant);
    }
  };
  inline std__variant_nitro__NullType__NitroVerifyPurchaseWithIapkitGoogleProps_ create_std__variant_nitro__NullType__NitroVerifyPurchaseWithIapkitGoogleProps_(nitro::NullType value) noexcept {
    return std__variant_nitro__NullType__NitroVerifyPurchaseWithIapkitGoogleProps_(value);
  }
  inline std__variant_nitro__NullType__NitroVerifyPurchaseWithIapkitGoogleProps_ create_std__variant_nitro__NullType__NitroVerifyPurchaseWithIapkitGoogleProps_(const NitroVerifyPurchaseWithIapkitGoogleProps& value) noexcept {
    return std__variant_nitro__NullType__NitroVerifyPurchaseWithIapkitGoogleProps_(value);
  }
  
  // pragma MARK: std::optional<std::variant<nitro::NullType, NitroVerifyPurchaseWithIapkitGoogleProps>>
  /**
   * Specialized version of `std::optional<std::variant<nitro::NullType, NitroVerifyPurchaseWithIapkitGoogleProps>>`.
   */
  using std__optional_std__variant_nitro__NullType__NitroVerifyPurchaseWithIapkitGoogleProps__ = std::optional<std::variant<nitro::NullType, NitroVerifyPurchaseWithIapkitGoogleProps>>;
  inline std::optional<std::variant<nitro::NullType, NitroVerifyPurchaseWithIapkitGoogleProps>> create_std__optional_std__variant_nitro__NullType__NitroVerifyPurchaseWithIapkitGoogleProps__(const std::variant<nitro::NullType, NitroVerifyPurchaseWithIapkitGoogleProps>& value) noexcept {
    return std::optional<std::variant<nitro::NullType, NitroVerifyPurchaseWithIapkitGoogleProps>>(value);
  }
  inline bool has_value_std__optional_std__variant_nitro__NullType__NitroVerifyPurchaseWithIapkitGoogleProps__(const std::optional<std::variant<nitro::NullType, NitroVerifyPurchaseWithIapkitGoogleProps>>& optional) noexcept {
    return optional.has_value();
  }
  inline std::variant<nitro::NullType, NitroVerifyPurchaseWithIapkitGoogleProps> get_std__optional_std__variant_nitro__NullType__NitroVerifyPurchaseWithIapkitGoogleProps__(const std::optional<std::variant<nitro::NullType, NitroVerifyPurchaseWithIapkitGoogleProps>>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::variant<nitro::NullType, NitroVerifyPurchaseWithIapkitProps>
  /**
   * Wrapper struct for `std::variant<nitro::NullType, NitroVerifyPurchaseWithIapkitProps>`.
   * std::variant cannot be used in Swift because of a Swift bug.
   * Not even specializing it works. So we create a wrapper struct.
   */
  struct std__variant_nitro__NullType__NitroVerifyPurchaseWithIapkitProps_ final {
    std::variant<nitro::NullType, NitroVerifyPurchaseWithIapkitProps> variant;
    std__variant_nitro__NullType__NitroVerifyPurchaseWithIapkitProps_(std::variant<nitro::NullType, NitroVerifyPurchaseWithIapkitProps> variant): variant(variant) { }
    operator std::variant<nitro::NullType, NitroVerifyPurchaseWithIapkitProps>() const noexcept {
      return variant;
    }
    inline size_t index() const noexcept {
      return variant.index();
    }
    inline nitro::NullType get_0() const noexcept {
      return std::get<0>(variant);
    }
    inline NitroVerifyPurchaseWithIapkitProps get_1() const noexcept {
      return std::get<1>(variant);
    }
  };
  inline std__variant_nitro__NullType__NitroVerifyPurchaseWithIapkitProps_ create_std__variant_nitro__NullType__NitroVerifyPurchaseWithIapkitProps_(nitro::NullType value) noexcept {
    return std__variant_nitro__NullType__NitroVerifyPurchaseWithIapkitProps_(value);
  }
  inline std__variant_nitro__NullType__NitroVerifyPurchaseWithIapkitProps_ create_std__variant_nitro__NullType__NitroVerifyPurchaseWithIapkitProps_(const NitroVerifyPurchaseWithIapkitProps& value) noexcept {
    return std__variant_nitro__NullType__NitroVerifyPurchaseWithIapkitProps_(value);
  }
  
  // pragma MARK: std::optional<std::variant<nitro::NullType, NitroVerifyPurchaseWithIapkitProps>>
  /**
   * Specialized version of `std::optional<std::variant<nitro::NullType, NitroVerifyPurchaseWithIapkitProps>>`.
   */
  using std__optional_std__variant_nitro__NullType__NitroVerifyPurchaseWithIapkitProps__ = std::optional<std::variant<nitro::NullType, NitroVerifyPurchaseWithIapkitProps>>;
  inline std::optional<std::variant<nitro::NullType, NitroVerifyPurchaseWithIapkitProps>> create_std__optional_std__variant_nitro__NullType__NitroVerifyPurchaseWithIapkitProps__(const std::variant<nitro::NullType, NitroVerifyPurchaseWithIapkitProps>& value) noexcept {
    return std::optional<std::variant<nitro::NullType, NitroVerifyPurchaseWithIapkitProps>>(value);
  }
  inline bool has_value_std__optional_std__variant_nitro__NullType__NitroVerifyPurchaseWithIapkitProps__(const std::optional<std::variant<nitro::NullType, NitroVerifyPurchaseWithIapkitProps>>& optional) noexcept {
    return optional.has_value();
  }
  inline std::variant<nitro::NullType, NitroVerifyPurchaseWithIapkitProps> get_std__optional_std__variant_nitro__NullType__NitroVerifyPurchaseWithIapkitProps__(const std::optional<std::variant<nitro::NullType, NitroVerifyPurchaseWithIapkitProps>>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::function<void(const UserChoiceBillingDetails& /* details */)>
  /**
   * Specialized version of `std::function<void(const UserChoiceBillingDetails&)>`.
   */
  using Func_void_UserChoiceBillingDetails = std::function<void(const UserChoiceBillingDetails& /* details */)>;
  /**
   * Wrapper class for a `std::function<void(const UserChoiceBillingDetails& / * details * /)>`, this can be used from Swift.
   */
  class Func_void_UserChoiceBillingDetails_Wrapper final {
  public:
    explicit Func_void_UserChoiceBillingDetails_Wrapper(std::function<void(const UserChoiceBillingDetails& /* details */)>&& func): _function(std::make_unique<std::function<void(const UserChoiceBillingDetails& /* details */)>>(std::move(func))) {}
    inline void call(UserChoiceBillingDetails details) const noexcept {
      _function->operator()(details);
    }
  private:
    std::unique_ptr<std::function<void(const UserChoiceBillingDetails& /* details */)>> _function;
  } SWIFT_NONCOPYABLE;
  Func_void_UserChoiceBillingDetails create_Func_void_UserChoiceBillingDetails(void* NON_NULL swiftClosureWrapper) noexcept;
  inline Func_void_UserChoiceBillingDetails_Wrapper wrap_Func_void_UserChoiceBillingDetails(Func_void_UserChoiceBillingDetails value) noexcept {
    return Func_void_UserChoiceBillingDetails_Wrapper(std::move(value));
  }
  
  // pragma MARK: std::function<void(const DeveloperProvidedBillingDetailsAndroid& /* details */)>
  /**
   * Specialized version of `std::function<void(const DeveloperProvidedBillingDetailsAndroid&)>`.
   */
  using Func_void_DeveloperProvidedBillingDetailsAndroid = std::function<void(const DeveloperProvidedBillingDetailsAndroid& /* details */)>;
  /**
   * Wrapper class for a `std::function<void(const DeveloperProvidedBillingDetailsAndroid& / * details * /)>`, this can be used from Swift.
   */
  class Func_void_DeveloperProvidedBillingDetailsAndroid_Wrapper final {
  public:
    explicit Func_void_DeveloperProvidedBillingDetailsAndroid_Wrapper(std::function<void(const DeveloperProvidedBillingDetailsAndroid& /* details */)>&& func): _function(std::make_unique<std::function<void(const DeveloperProvidedBillingDetailsAndroid& /* details */)>>(std::move(func))) {}
    inline void call(DeveloperProvidedBillingDetailsAndroid details) const noexcept {
      _function->operator()(details);
    }
  private:
    std::unique_ptr<std::function<void(const DeveloperProvidedBillingDetailsAndroid& /* details */)>> _function;
  } SWIFT_NONCOPYABLE;
  Func_void_DeveloperProvidedBillingDetailsAndroid create_Func_void_DeveloperProvidedBillingDetailsAndroid(void* NON_NULL swiftClosureWrapper) noexcept;
  inline Func_void_DeveloperProvidedBillingDetailsAndroid_Wrapper wrap_Func_void_DeveloperProvidedBillingDetailsAndroid(Func_void_DeveloperProvidedBillingDetailsAndroid value) noexcept {
    return Func_void_DeveloperProvidedBillingDetailsAndroid_Wrapper(std::move(value));
  }
  
  // pragma MARK: std::shared_ptr<Promise<NitroBillingProgramAvailabilityResultAndroid>>
  /**
   * Specialized version of `std::shared_ptr<Promise<NitroBillingProgramAvailabilityResultAndroid>>`.
   */
  using std__shared_ptr_Promise_NitroBillingProgramAvailabilityResultAndroid__ = std::shared_ptr<Promise<NitroBillingProgramAvailabilityResultAndroid>>;
  inline std::shared_ptr<Promise<NitroBillingProgramAvailabilityResultAndroid>> create_std__shared_ptr_Promise_NitroBillingProgramAvailabilityResultAndroid__() noexcept {
    return Promise<NitroBillingProgramAvailabilityResultAndroid>::create();
  }
  inline PromiseHolder<NitroBillingProgramAvailabilityResultAndroid> wrap_std__shared_ptr_Promise_NitroBillingProgramAvailabilityResultAndroid__(std::shared_ptr<Promise<NitroBillingProgramAvailabilityResultAndroid>> promise) noexcept {
    return PromiseHolder<NitroBillingProgramAvailabilityResultAndroid>(std::move(promise));
  }
  
  // pragma MARK: std::function<void(const NitroBillingProgramAvailabilityResultAndroid& /* result */)>
  /**
   * Specialized version of `std::function<void(const NitroBillingProgramAvailabilityResultAndroid&)>`.
   */
  using Func_void_NitroBillingProgramAvailabilityResultAndroid = std::function<void(const NitroBillingProgramAvailabilityResultAndroid& /* result */)>;
  /**
   * Wrapper class for a `std::function<void(const NitroBillingProgramAvailabilityResultAndroid& / * result * /)>`, this can be used from Swift.
   */
  class Func_void_NitroBillingProgramAvailabilityResultAndroid_Wrapper final {
  public:
    explicit Func_void_NitroBillingProgramAvailabilityResultAndroid_Wrapper(std::function<void(const NitroBillingProgramAvailabilityResultAndroid& /* result */)>&& func): _function(std::make_unique<std::function<void(const NitroBillingProgramAvailabilityResultAndroid& /* result */)>>(std::move(func))) {}
    inline void call(NitroBillingProgramAvailabilityResultAndroid result) const noexcept {
      _function->operator()(result);
    }
  private:
    std::unique_ptr<std::function<void(const NitroBillingProgramAvailabilityResultAndroid& /* result */)>> _function;
  } SWIFT_NONCOPYABLE;
  Func_void_NitroBillingProgramAvailabilityResultAndroid create_Func_void_NitroBillingProgramAvailabilityResultAndroid(void* NON_NULL swiftClosureWrapper) noexcept;
  inline Func_void_NitroBillingProgramAvailabilityResultAndroid_Wrapper wrap_Func_void_NitroBillingProgramAvailabilityResultAndroid(Func_void_NitroBillingProgramAvailabilityResultAndroid value) noexcept {
    return Func_void_NitroBillingProgramAvailabilityResultAndroid_Wrapper(std::move(value));
  }
  
  // pragma MARK: std::shared_ptr<Promise<NitroBillingProgramReportingDetailsAndroid>>
  /**
   * Specialized version of `std::shared_ptr<Promise<NitroBillingProgramReportingDetailsAndroid>>`.
   */
  using std__shared_ptr_Promise_NitroBillingProgramReportingDetailsAndroid__ = std::shared_ptr<Promise<NitroBillingProgramReportingDetailsAndroid>>;
  inline std::shared_ptr<Promise<NitroBillingProgramReportingDetailsAndroid>> create_std__shared_ptr_Promise_NitroBillingProgramReportingDetailsAndroid__() noexcept {
    return Promise<NitroBillingProgramReportingDetailsAndroid>::create();
  }
  inline PromiseHolder<NitroBillingProgramReportingDetailsAndroid> wrap_std__shared_ptr_Promise_NitroBillingProgramReportingDetailsAndroid__(std::shared_ptr<Promise<NitroBillingProgramReportingDetailsAndroid>> promise) noexcept {
    return PromiseHolder<NitroBillingProgramReportingDetailsAndroid>(std::move(promise));
  }
  
  // pragma MARK: std::function<void(const NitroBillingProgramReportingDetailsAndroid& /* result */)>
  /**
   * Specialized version of `std::function<void(const NitroBillingProgramReportingDetailsAndroid&)>`.
   */
  using Func_void_NitroBillingProgramReportingDetailsAndroid = std::function<void(const NitroBillingProgramReportingDetailsAndroid& /* result */)>;
  /**
   * Wrapper class for a `std::function<void(const NitroBillingProgramReportingDetailsAndroid& / * result * /)>`, this can be used from Swift.
   */
  class Func_void_NitroBillingProgramReportingDetailsAndroid_Wrapper final {
  public:
    explicit Func_void_NitroBillingProgramReportingDetailsAndroid_Wrapper(std::function<void(const NitroBillingProgramReportingDetailsAndroid& /* result */)>&& func): _function(std::make_unique<std::function<void(const NitroBillingProgramReportingDetailsAndroid& /* result */)>>(std::move(func))) {}
    inline void call(NitroBillingProgramReportingDetailsAndroid result) const noexcept {
      _function->operator()(result);
    }
  private:
    std::unique_ptr<std::function<void(const NitroBillingProgramReportingDetailsAndroid& /* result */)>> _function;
  } SWIFT_NONCOPYABLE;
  Func_void_NitroBillingProgramReportingDetailsAndroid create_Func_void_NitroBillingProgramReportingDetailsAndroid(void* NON_NULL swiftClosureWrapper) noexcept;
  inline Func_void_NitroBillingProgramReportingDetailsAndroid_Wrapper wrap_Func_void_NitroBillingProgramReportingDetailsAndroid(Func_void_NitroBillingProgramReportingDetailsAndroid value) noexcept {
    return Func_void_NitroBillingProgramReportingDetailsAndroid_Wrapper(std::move(value));
  }
  
  // pragma MARK: std::shared_ptr<Promise<ExternalPurchaseNoticeResultIOS>>
  /**
   * Specialized version of `std::shared_ptr<Promise<ExternalPurchaseNoticeResultIOS>>`.
   */
  using std__shared_ptr_Promise_ExternalPurchaseNoticeResultIOS__ = std::shared_ptr<Promise<ExternalPurchaseNoticeResultIOS>>;
  inline std::shared_ptr<Promise<ExternalPurchaseNoticeResultIOS>> create_std__shared_ptr_Promise_ExternalPurchaseNoticeResultIOS__() noexcept {
    return Promise<ExternalPurchaseNoticeResultIOS>::create();
  }
  inline PromiseHolder<ExternalPurchaseNoticeResultIOS> wrap_std__shared_ptr_Promise_ExternalPurchaseNoticeResultIOS__(std::shared_ptr<Promise<ExternalPurchaseNoticeResultIOS>> promise) noexcept {
    return PromiseHolder<ExternalPurchaseNoticeResultIOS>(std::move(promise));
  }
  
  // pragma MARK: std::function<void(const ExternalPurchaseNoticeResultIOS& /* result */)>
  /**
   * Specialized version of `std::function<void(const ExternalPurchaseNoticeResultIOS&)>`.
   */
  using Func_void_ExternalPurchaseNoticeResultIOS = std::function<void(const ExternalPurchaseNoticeResultIOS& /* result */)>;
  /**
   * Wrapper class for a `std::function<void(const ExternalPurchaseNoticeResultIOS& / * result * /)>`, this can be used from Swift.
   */
  class Func_void_ExternalPurchaseNoticeResultIOS_Wrapper final {
  public:
    explicit Func_void_ExternalPurchaseNoticeResultIOS_Wrapper(std::function<void(const ExternalPurchaseNoticeResultIOS& /* result */)>&& func): _function(std::make_unique<std::function<void(const ExternalPurchaseNoticeResultIOS& /* result */)>>(std::move(func))) {}
    inline void call(ExternalPurchaseNoticeResultIOS result) const noexcept {
      _function->operator()(result);
    }
  private:
    std::unique_ptr<std::function<void(const ExternalPurchaseNoticeResultIOS& /* result */)>> _function;
  } SWIFT_NONCOPYABLE;
  Func_void_ExternalPurchaseNoticeResultIOS create_Func_void_ExternalPurchaseNoticeResultIOS(void* NON_NULL swiftClosureWrapper) noexcept;
  inline Func_void_ExternalPurchaseNoticeResultIOS_Wrapper wrap_Func_void_ExternalPurchaseNoticeResultIOS(Func_void_ExternalPurchaseNoticeResultIOS value) noexcept {
    return Func_void_ExternalPurchaseNoticeResultIOS_Wrapper(std::move(value));
  }
  
  // pragma MARK: std::shared_ptr<Promise<ExternalPurchaseLinkResultIOS>>
  /**
   * Specialized version of `std::shared_ptr<Promise<ExternalPurchaseLinkResultIOS>>`.
   */
  using std__shared_ptr_Promise_ExternalPurchaseLinkResultIOS__ = std::shared_ptr<Promise<ExternalPurchaseLinkResultIOS>>;
  inline std::shared_ptr<Promise<ExternalPurchaseLinkResultIOS>> create_std__shared_ptr_Promise_ExternalPurchaseLinkResultIOS__() noexcept {
    return Promise<ExternalPurchaseLinkResultIOS>::create();
  }
  inline PromiseHolder<ExternalPurchaseLinkResultIOS> wrap_std__shared_ptr_Promise_ExternalPurchaseLinkResultIOS__(std::shared_ptr<Promise<ExternalPurchaseLinkResultIOS>> promise) noexcept {
    return PromiseHolder<ExternalPurchaseLinkResultIOS>(std::move(promise));
  }
  
  // pragma MARK: std::function<void(const ExternalPurchaseLinkResultIOS& /* result */)>
  /**
   * Specialized version of `std::function<void(const ExternalPurchaseLinkResultIOS&)>`.
   */
  using Func_void_ExternalPurchaseLinkResultIOS = std::function<void(const ExternalPurchaseLinkResultIOS& /* result */)>;
  /**
   * Wrapper class for a `std::function<void(const ExternalPurchaseLinkResultIOS& / * result * /)>`, this can be used from Swift.
   */
  class Func_void_ExternalPurchaseLinkResultIOS_Wrapper final {
  public:
    explicit Func_void_ExternalPurchaseLinkResultIOS_Wrapper(std::function<void(const ExternalPurchaseLinkResultIOS& /* result */)>&& func): _function(std::make_unique<std::function<void(const ExternalPurchaseLinkResultIOS& /* result */)>>(std::move(func))) {}
    inline void call(ExternalPurchaseLinkResultIOS result) const noexcept {
      _function->operator()(result);
    }
  private:
    std::unique_ptr<std::function<void(const ExternalPurchaseLinkResultIOS& /* result */)>> _function;
  } SWIFT_NONCOPYABLE;
  Func_void_ExternalPurchaseLinkResultIOS create_Func_void_ExternalPurchaseLinkResultIOS(void* NON_NULL swiftClosureWrapper) noexcept;
  inline Func_void_ExternalPurchaseLinkResultIOS_Wrapper wrap_Func_void_ExternalPurchaseLinkResultIOS(Func_void_ExternalPurchaseLinkResultIOS value) noexcept {
    return Func_void_ExternalPurchaseLinkResultIOS_Wrapper(std::move(value));
  }
  
  // pragma MARK: std::shared_ptr<HybridRnIapSpec>
  /**
   * Specialized version of `std::shared_ptr<HybridRnIapSpec>`.
   */
  using std__shared_ptr_HybridRnIapSpec_ = std::shared_ptr<HybridRnIapSpec>;
  std::shared_ptr<HybridRnIapSpec> create_std__shared_ptr_HybridRnIapSpec_(void* NON_NULL swiftUnsafePointer) noexcept;
  void* NON_NULL get_std__shared_ptr_HybridRnIapSpec_(std__shared_ptr_HybridRnIapSpec_ cppType);
  
  // pragma MARK: std::weak_ptr<HybridRnIapSpec>
  using std__weak_ptr_HybridRnIapSpec_ = std::weak_ptr<HybridRnIapSpec>;
  inline std__weak_ptr_HybridRnIapSpec_ weakify_std__shared_ptr_HybridRnIapSpec_(const std::shared_ptr<HybridRnIapSpec>& strong) noexcept { return strong; }
  
  // pragma MARK: Result<std::shared_ptr<Promise<bool>>>
  using Result_std__shared_ptr_Promise_bool___ = Result<std::shared_ptr<Promise<bool>>>;
  inline Result_std__shared_ptr_Promise_bool___ create_Result_std__shared_ptr_Promise_bool___(const std::shared_ptr<Promise<bool>>& value) noexcept {
    return Result<std::shared_ptr<Promise<bool>>>::withValue(value);
  }
  inline Result_std__shared_ptr_Promise_bool___ create_Result_std__shared_ptr_Promise_bool___(const std::exception_ptr& error) noexcept {
    return Result<std::shared_ptr<Promise<bool>>>::withError(error);
  }
  
  // pragma MARK: Result<std::shared_ptr<Promise<std::vector<NitroProduct>>>>
  using Result_std__shared_ptr_Promise_std__vector_NitroProduct____ = Result<std::shared_ptr<Promise<std::vector<NitroProduct>>>>;
  inline Result_std__shared_ptr_Promise_std__vector_NitroProduct____ create_Result_std__shared_ptr_Promise_std__vector_NitroProduct____(const std::shared_ptr<Promise<std::vector<NitroProduct>>>& value) noexcept {
    return Result<std::shared_ptr<Promise<std::vector<NitroProduct>>>>::withValue(value);
  }
  inline Result_std__shared_ptr_Promise_std__vector_NitroProduct____ create_Result_std__shared_ptr_Promise_std__vector_NitroProduct____(const std::exception_ptr& error) noexcept {
    return Result<std::shared_ptr<Promise<std::vector<NitroProduct>>>>::withError(error);
  }
  
  // pragma MARK: Result<std::shared_ptr<Promise<std::variant<nitro::NullType, PurchaseAndroid, PurchaseIOS, std::vector<std::variant<PurchaseAndroid, PurchaseIOS>>>>>>
  using Result_std__shared_ptr_Promise_std__variant_nitro__NullType__PurchaseAndroid__PurchaseIOS__std__vector_std__variant_PurchaseAndroid__PurchaseIOS______ = Result<std::shared_ptr<Promise<std::variant<nitro::NullType, PurchaseAndroid, PurchaseIOS, std::vector<std::variant<PurchaseAndroid, PurchaseIOS>>>>>>;
  inline Result_std__shared_ptr_Promise_std__variant_nitro__NullType__PurchaseAndroid__PurchaseIOS__std__vector_std__variant_PurchaseAndroid__PurchaseIOS______ create_Result_std__shared_ptr_Promise_std__variant_nitro__NullType__PurchaseAndroid__PurchaseIOS__std__vector_std__variant_PurchaseAndroid__PurchaseIOS______(const std::shared_ptr<Promise<std::variant<nitro::NullType, PurchaseAndroid, PurchaseIOS, std::vector<std::variant<PurchaseAndroid, PurchaseIOS>>>>>& value) noexcept {
    return Result<std::shared_ptr<Promise<std::variant<nitro::NullType, PurchaseAndroid, PurchaseIOS, std::vector<std::variant<PurchaseAndroid, PurchaseIOS>>>>>>::withValue(value);
  }
  inline Result_std__shared_ptr_Promise_std__variant_nitro__NullType__PurchaseAndroid__PurchaseIOS__std__vector_std__variant_PurchaseAndroid__PurchaseIOS______ create_Result_std__shared_ptr_Promise_std__variant_nitro__NullType__PurchaseAndroid__PurchaseIOS__std__vector_std__variant_PurchaseAndroid__PurchaseIOS______(const std::exception_ptr& error) noexcept {
    return Result<std::shared_ptr<Promise<std::variant<nitro::NullType, PurchaseAndroid, PurchaseIOS, std::vector<std::variant<PurchaseAndroid, PurchaseIOS>>>>>>::withError(error);
  }
  
  // pragma MARK: Result<std::shared_ptr<Promise<std::vector<NitroPurchase>>>>
  using Result_std__shared_ptr_Promise_std__vector_NitroPurchase____ = Result<std::shared_ptr<Promise<std::vector<NitroPurchase>>>>;
  inline Result_std__shared_ptr_Promise_std__vector_NitroPurchase____ create_Result_std__shared_ptr_Promise_std__vector_NitroPurchase____(const std::shared_ptr<Promise<std::vector<NitroPurchase>>>& value) noexcept {
    return Result<std::shared_ptr<Promise<std::vector<NitroPurchase>>>>::withValue(value);
  }
  inline Result_std__shared_ptr_Promise_std__vector_NitroPurchase____ create_Result_std__shared_ptr_Promise_std__vector_NitroPurchase____(const std::exception_ptr& error) noexcept {
    return Result<std::shared_ptr<Promise<std::vector<NitroPurchase>>>>::withError(error);
  }
  
  // pragma MARK: Result<std::shared_ptr<Promise<std::vector<NitroActiveSubscription>>>>
  using Result_std__shared_ptr_Promise_std__vector_NitroActiveSubscription____ = Result<std::shared_ptr<Promise<std::vector<NitroActiveSubscription>>>>;
  inline Result_std__shared_ptr_Promise_std__vector_NitroActiveSubscription____ create_Result_std__shared_ptr_Promise_std__vector_NitroActiveSubscription____(const std::shared_ptr<Promise<std::vector<NitroActiveSubscription>>>& value) noexcept {
    return Result<std::shared_ptr<Promise<std::vector<NitroActiveSubscription>>>>::withValue(value);
  }
  inline Result_std__shared_ptr_Promise_std__vector_NitroActiveSubscription____ create_Result_std__shared_ptr_Promise_std__vector_NitroActiveSubscription____(const std::exception_ptr& error) noexcept {
    return Result<std::shared_ptr<Promise<std::vector<NitroActiveSubscription>>>>::withError(error);
  }
  
  // pragma MARK: Result<std::shared_ptr<Promise<std::variant<bool, NitroPurchaseResult>>>>
  using Result_std__shared_ptr_Promise_std__variant_bool__NitroPurchaseResult____ = Result<std::shared_ptr<Promise<std::variant<bool, NitroPurchaseResult>>>>;
  inline Result_std__shared_ptr_Promise_std__variant_bool__NitroPurchaseResult____ create_Result_std__shared_ptr_Promise_std__variant_bool__NitroPurchaseResult____(const std::shared_ptr<Promise<std::variant<bool, NitroPurchaseResult>>>& value) noexcept {
    return Result<std::shared_ptr<Promise<std::variant<bool, NitroPurchaseResult>>>>::withValue(value);
  }
  inline Result_std__shared_ptr_Promise_std__variant_bool__NitroPurchaseResult____ create_Result_std__shared_ptr_Promise_std__variant_bool__NitroPurchaseResult____(const std::exception_ptr& error) noexcept {
    return Result<std::shared_ptr<Promise<std::variant<bool, NitroPurchaseResult>>>>::withError(error);
  }
  
  // pragma MARK: Result<void>
  using Result_void_ = Result<void>;
  inline Result_void_ create_Result_void_() noexcept {
    return Result<void>::withValue();
  }
  inline Result_void_ create_Result_void_(const std::exception_ptr& error) noexcept {
    return Result<void>::withError(error);
  }
  
  // pragma MARK: Result<std::shared_ptr<Promise<std::string>>>
  using Result_std__shared_ptr_Promise_std__string___ = Result<std::shared_ptr<Promise<std::string>>>;
  inline Result_std__shared_ptr_Promise_std__string___ create_Result_std__shared_ptr_Promise_std__string___(const std::shared_ptr<Promise<std::string>>& value) noexcept {
    return Result<std::shared_ptr<Promise<std::string>>>::withValue(value);
  }
  inline Result_std__shared_ptr_Promise_std__string___ create_Result_std__shared_ptr_Promise_std__string___(const std::exception_ptr& error) noexcept {
    return Result<std::shared_ptr<Promise<std::string>>>::withError(error);
  }
  
  // pragma MARK: Result<std::shared_ptr<Promise<std::variant<nitro::NullType, std::string>>>>
  using Result_std__shared_ptr_Promise_std__variant_nitro__NullType__std__string____ = Result<std::shared_ptr<Promise<std::variant<nitro::NullType, std::string>>>>;
  inline Result_std__shared_ptr_Promise_std__variant_nitro__NullType__std__string____ create_Result_std__shared_ptr_Promise_std__variant_nitro__NullType__std__string____(const std::shared_ptr<Promise<std::variant<nitro::NullType, std::string>>>& value) noexcept {
    return Result<std::shared_ptr<Promise<std::variant<nitro::NullType, std::string>>>>::withValue(value);
  }
  inline Result_std__shared_ptr_Promise_std__variant_nitro__NullType__std__string____ create_Result_std__shared_ptr_Promise_std__variant_nitro__NullType__std__string____(const std::exception_ptr& error) noexcept {
    return Result<std::shared_ptr<Promise<std::variant<nitro::NullType, std::string>>>>::withError(error);
  }
  
  // pragma MARK: Result<std::shared_ptr<Promise<std::variant<nitro::NullType, NitroProduct>>>>
  using Result_std__shared_ptr_Promise_std__variant_nitro__NullType__NitroProduct____ = Result<std::shared_ptr<Promise<std::variant<nitro::NullType, NitroProduct>>>>;
  inline Result_std__shared_ptr_Promise_std__variant_nitro__NullType__NitroProduct____ create_Result_std__shared_ptr_Promise_std__variant_nitro__NullType__NitroProduct____(const std::shared_ptr<Promise<std::variant<nitro::NullType, NitroProduct>>>& value) noexcept {
    return Result<std::shared_ptr<Promise<std::variant<nitro::NullType, NitroProduct>>>>::withValue(value);
  }
  inline Result_std__shared_ptr_Promise_std__variant_nitro__NullType__NitroProduct____ create_Result_std__shared_ptr_Promise_std__variant_nitro__NullType__NitroProduct____(const std::exception_ptr& error) noexcept {
    return Result<std::shared_ptr<Promise<std::variant<nitro::NullType, NitroProduct>>>>::withError(error);
  }
  
  // pragma MARK: Result<std::shared_ptr<Promise<void>>>
  using Result_std__shared_ptr_Promise_void___ = Result<std::shared_ptr<Promise<void>>>;
  inline Result_std__shared_ptr_Promise_void___ create_Result_std__shared_ptr_Promise_void___(const std::shared_ptr<Promise<void>>& value) noexcept {
    return Result<std::shared_ptr<Promise<void>>>::withValue(value);
  }
  inline Result_std__shared_ptr_Promise_void___ create_Result_std__shared_ptr_Promise_void___(const std::exception_ptr& error) noexcept {
    return Result<std::shared_ptr<Promise<void>>>::withError(error);
  }
  
  // pragma MARK: Result<std::shared_ptr<Promise<std::variant<nitro::NullType, std::vector<NitroSubscriptionStatus>>>>>
  using Result_std__shared_ptr_Promise_std__variant_nitro__NullType__std__vector_NitroSubscriptionStatus_____ = Result<std::shared_ptr<Promise<std::variant<nitro::NullType, std::vector<NitroSubscriptionStatus>>>>>;
  inline Result_std__shared_ptr_Promise_std__variant_nitro__NullType__std__vector_NitroSubscriptionStatus_____ create_Result_std__shared_ptr_Promise_std__variant_nitro__NullType__std__vector_NitroSubscriptionStatus_____(const std::shared_ptr<Promise<std::variant<nitro::NullType, std::vector<NitroSubscriptionStatus>>>>& value) noexcept {
    return Result<std::shared_ptr<Promise<std::variant<nitro::NullType, std::vector<NitroSubscriptionStatus>>>>>::withValue(value);
  }
  inline Result_std__shared_ptr_Promise_std__variant_nitro__NullType__std__vector_NitroSubscriptionStatus_____ create_Result_std__shared_ptr_Promise_std__variant_nitro__NullType__std__vector_NitroSubscriptionStatus_____(const std::exception_ptr& error) noexcept {
    return Result<std::shared_ptr<Promise<std::variant<nitro::NullType, std::vector<NitroSubscriptionStatus>>>>>::withError(error);
  }
  
  // pragma MARK: Result<std::shared_ptr<Promise<std::variant<nitro::NullType, NitroPurchase>>>>
  using Result_std__shared_ptr_Promise_std__variant_nitro__NullType__NitroPurchase____ = Result<std::shared_ptr<Promise<std::variant<nitro::NullType, NitroPurchase>>>>;
  inline Result_std__shared_ptr_Promise_std__variant_nitro__NullType__NitroPurchase____ create_Result_std__shared_ptr_Promise_std__variant_nitro__NullType__NitroPurchase____(const std::shared_ptr<Promise<std::variant<nitro::NullType, NitroPurchase>>>& value) noexcept {
    return Result<std::shared_ptr<Promise<std::variant<nitro::NullType, NitroPurchase>>>>::withValue(value);
  }
  inline Result_std__shared_ptr_Promise_std__variant_nitro__NullType__NitroPurchase____ create_Result_std__shared_ptr_Promise_std__variant_nitro__NullType__NitroPurchase____(const std::exception_ptr& error) noexcept {
    return Result<std::shared_ptr<Promise<std::variant<nitro::NullType, NitroPurchase>>>>::withError(error);
  }
  
  // pragma MARK: Result<std::shared_ptr<Promise<std::variant<NitroReceiptValidationResultIOS, NitroReceiptValidationResultAndroid>>>>
  using Result_std__shared_ptr_Promise_std__variant_NitroReceiptValidationResultIOS__NitroReceiptValidationResultAndroid____ = Result<std::shared_ptr<Promise<std::variant<NitroReceiptValidationResultIOS, NitroReceiptValidationResultAndroid>>>>;
  inline Result_std__shared_ptr_Promise_std__variant_NitroReceiptValidationResultIOS__NitroReceiptValidationResultAndroid____ create_Result_std__shared_ptr_Promise_std__variant_NitroReceiptValidationResultIOS__NitroReceiptValidationResultAndroid____(const std::shared_ptr<Promise<std::variant<NitroReceiptValidationResultIOS, NitroReceiptValidationResultAndroid>>>& value) noexcept {
    return Result<std::shared_ptr<Promise<std::variant<NitroReceiptValidationResultIOS, NitroReceiptValidationResultAndroid>>>>::withValue(value);
  }
  inline Result_std__shared_ptr_Promise_std__variant_NitroReceiptValidationResultIOS__NitroReceiptValidationResultAndroid____ create_Result_std__shared_ptr_Promise_std__variant_NitroReceiptValidationResultIOS__NitroReceiptValidationResultAndroid____(const std::exception_ptr& error) noexcept {
    return Result<std::shared_ptr<Promise<std::variant<NitroReceiptValidationResultIOS, NitroReceiptValidationResultAndroid>>>>::withError(error);
  }
  
  // pragma MARK: Result<std::shared_ptr<Promise<NitroVerifyPurchaseWithProviderResult>>>
  using Result_std__shared_ptr_Promise_NitroVerifyPurchaseWithProviderResult___ = Result<std::shared_ptr<Promise<NitroVerifyPurchaseWithProviderResult>>>;
  inline Result_std__shared_ptr_Promise_NitroVerifyPurchaseWithProviderResult___ create_Result_std__shared_ptr_Promise_NitroVerifyPurchaseWithProviderResult___(const std::shared_ptr<Promise<NitroVerifyPurchaseWithProviderResult>>& value) noexcept {
    return Result<std::shared_ptr<Promise<NitroVerifyPurchaseWithProviderResult>>>::withValue(value);
  }
  inline Result_std__shared_ptr_Promise_NitroVerifyPurchaseWithProviderResult___ create_Result_std__shared_ptr_Promise_NitroVerifyPurchaseWithProviderResult___(const std::exception_ptr& error) noexcept {
    return Result<std::shared_ptr<Promise<NitroVerifyPurchaseWithProviderResult>>>::withError(error);
  }
  
  // pragma MARK: Result<std::shared_ptr<Promise<NitroBillingProgramAvailabilityResultAndroid>>>
  using Result_std__shared_ptr_Promise_NitroBillingProgramAvailabilityResultAndroid___ = Result<std::shared_ptr<Promise<NitroBillingProgramAvailabilityResultAndroid>>>;
  inline Result_std__shared_ptr_Promise_NitroBillingProgramAvailabilityResultAndroid___ create_Result_std__shared_ptr_Promise_NitroBillingProgramAvailabilityResultAndroid___(const std::shared_ptr<Promise<NitroBillingProgramAvailabilityResultAndroid>>& value) noexcept {
    return Result<std::shared_ptr<Promise<NitroBillingProgramAvailabilityResultAndroid>>>::withValue(value);
  }
  inline Result_std__shared_ptr_Promise_NitroBillingProgramAvailabilityResultAndroid___ create_Result_std__shared_ptr_Promise_NitroBillingProgramAvailabilityResultAndroid___(const std::exception_ptr& error) noexcept {
    return Result<std::shared_ptr<Promise<NitroBillingProgramAvailabilityResultAndroid>>>::withError(error);
  }
  
  // pragma MARK: Result<std::shared_ptr<Promise<NitroBillingProgramReportingDetailsAndroid>>>
  using Result_std__shared_ptr_Promise_NitroBillingProgramReportingDetailsAndroid___ = Result<std::shared_ptr<Promise<NitroBillingProgramReportingDetailsAndroid>>>;
  inline Result_std__shared_ptr_Promise_NitroBillingProgramReportingDetailsAndroid___ create_Result_std__shared_ptr_Promise_NitroBillingProgramReportingDetailsAndroid___(const std::shared_ptr<Promise<NitroBillingProgramReportingDetailsAndroid>>& value) noexcept {
    return Result<std::shared_ptr<Promise<NitroBillingProgramReportingDetailsAndroid>>>::withValue(value);
  }
  inline Result_std__shared_ptr_Promise_NitroBillingProgramReportingDetailsAndroid___ create_Result_std__shared_ptr_Promise_NitroBillingProgramReportingDetailsAndroid___(const std::exception_ptr& error) noexcept {
    return Result<std::shared_ptr<Promise<NitroBillingProgramReportingDetailsAndroid>>>::withError(error);
  }
  
  // pragma MARK: Result<std::shared_ptr<Promise<ExternalPurchaseNoticeResultIOS>>>
  using Result_std__shared_ptr_Promise_ExternalPurchaseNoticeResultIOS___ = Result<std::shared_ptr<Promise<ExternalPurchaseNoticeResultIOS>>>;
  inline Result_std__shared_ptr_Promise_ExternalPurchaseNoticeResultIOS___ create_Result_std__shared_ptr_Promise_ExternalPurchaseNoticeResultIOS___(const std::shared_ptr<Promise<ExternalPurchaseNoticeResultIOS>>& value) noexcept {
    return Result<std::shared_ptr<Promise<ExternalPurchaseNoticeResultIOS>>>::withValue(value);
  }
  inline Result_std__shared_ptr_Promise_ExternalPurchaseNoticeResultIOS___ create_Result_std__shared_ptr_Promise_ExternalPurchaseNoticeResultIOS___(const std::exception_ptr& error) noexcept {
    return Result<std::shared_ptr<Promise<ExternalPurchaseNoticeResultIOS>>>::withError(error);
  }
  
  // pragma MARK: Result<std::shared_ptr<Promise<ExternalPurchaseLinkResultIOS>>>
  using Result_std__shared_ptr_Promise_ExternalPurchaseLinkResultIOS___ = Result<std::shared_ptr<Promise<ExternalPurchaseLinkResultIOS>>>;
  inline Result_std__shared_ptr_Promise_ExternalPurchaseLinkResultIOS___ create_Result_std__shared_ptr_Promise_ExternalPurchaseLinkResultIOS___(const std::shared_ptr<Promise<ExternalPurchaseLinkResultIOS>>& value) noexcept {
    return Result<std::shared_ptr<Promise<ExternalPurchaseLinkResultIOS>>>::withValue(value);
  }
  inline Result_std__shared_ptr_Promise_ExternalPurchaseLinkResultIOS___ create_Result_std__shared_ptr_Promise_ExternalPurchaseLinkResultIOS___(const std::exception_ptr& error) noexcept {
    return Result<std::shared_ptr<Promise<ExternalPurchaseLinkResultIOS>>>::withError(error);
  }

} // namespace margelo::nitro::iap::bridge::swift
